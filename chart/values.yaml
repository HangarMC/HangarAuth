# Default values for hangarauth.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

frontend:
  replicaCount: 1

  image:
    repository: ghcr.io/papermc/hangarauth_frontend
    pullPolicy: Always
    # Overrides the image tag whose default is the chart appVersion.
    tag: "latest"

  imagePullSecrets: []
  nameOverride: ""
  fullnameOverride: ""

  serviceAccount:
    # Specifies whether a service account should be created
    create: true
    # Annotations to add to the service account
    annotations: {}
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    name: ""

  podAnnotations: {}

  podSecurityContext: {}
    # fsGroup: 2000

  securityContext: {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  service:
    type: ClusterIP
    port: 3000

  ingress:
    enabled: false
    className: ""
    annotations: {}
      # kubernetes.io/ingress.class: nginx
      # kubernetes.io/tls-acme: "true"
    hosts: []
#       - host: auth.hangar.test
#         paths:
#           - path: /
#             pathType: ImplementationSpecific
    tls: []
    #  - secretName: hangar-auth-tls
    #    hosts:
    #      - auth.hangar.test

  resources: {}
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 100
    targetCPUUtilizationPercentage: 80
    # targetMemoryUtilizationPercentage: 80

  nodeSelector: {}

  tolerations: []

  affinity: {}

  config:
    kratos:
      publicUrl: "https://auth.hangar.test/kratos"
      adminUrl: "http://hangarauth-kratos-admin"
      backendUrl: "http://hangarauth-kratos-public"
    publicHost: "https://auth.hangar.test"
    backendHost: "http://hangarauth-backend:8080"
    hangarHost: "https://hangar.test"
    debug: "hangar:*"
    signupDisabled: "false"

backend:
  replicaCount: 1

  image:
    repository: ghcr.io/papermc/hangarauth_backend
    pullPolicy: Always
    # Overrides the image tag whose default is the chart appVersion.
    tag: "latest"

  imagePullSecrets: []
  nameOverride: ""
  fullnameOverride: ""

  serviceAccount:
    # Specifies whether a service account should be created
    create: true
    # Annotations to add to the service account
    annotations: {}
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    name: ""

  podAnnotations: {}

  podSecurityContext: {}
    # fsGroup: 2000

  securityContext: {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  service:
    type: ClusterIP
    port: 8080

  resources: {}
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 100
    targetCPUUtilizationPercentage: 80
    # targetMemoryUtilizationPercentage: 80

  nodeSelector: {}

  tolerations: []

  affinity: {}

  config:
    postgresql:
      hostname: "hangarauth-postgresql"
      port: 5432
      username: "hangarauth"
      password: "hangarauth" # TODO: secret
      database: "hangarauth"
      options: "?currentSchema=auth"
    auth:
      publicHost: "https://auth.hangar.test"
      kratos:
        publicUrl: "https://auth.hangar.test/kratos"
        adminUrl: "http://hangarauth-kratos-admin"
      hydra:
        adminUrl: "http://hangarauth-hydra-admin:4445"

postgresql:
  enabled: true
  global:
    postgresql:
      auth:
        postgresPassword: "hangarauth"
        username: "hangarauth"
        password: "hangarauth"
        database: "hangarauth"

hydra:
  replicaCount: 1

  image:
    repository: oryd/hydra
    pullPolicy: Always
    tag: "v1.11.8"

  imagePullSecrets: []
  nameOverride: ""
  fullnameOverride: ""

  serviceAccount:
    # Specifies whether a service account should be created
    create: true
    # Annotations to add to the service account
    annotations: {}
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    name: ""

  podAnnotations: {}

  podSecurityContext: {}
    # fsGroup: 2000

  securityContext: {}
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  service:
    type: ClusterIP
    port: 4444

  ingress:
    public:
      enabled: false
      annotations:
        nginx.ingress.kubernetes.io/rewrite-target: /$2
      hosts: []
#        - host: "auth.hangar.test"
#          paths:
#            - path: "/hydra(/|$)(.*)"
#              pathType: ImplementationSpecific

  resources: {}
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 100
    targetCPUUtilizationPercentage: 80
    # targetMemoryUtilizationPercentage: 80

  nodeSelector: {}

  tolerations: []

  affinity: {}

  config:
    # todo abstract out values from the configmap, then abstract common values across all services

kratos:
  replicaCount: 1

  image:
    repository: oryd/kratos
    pullPolicy: Always
    tag: "v0.10.1"

  imagePullSecrets: [ ]
  nameOverride: ""
  fullnameOverride: ""

  serviceAccount:
    # Specifies whether a service account should be created
    create: true
    # Annotations to add to the service account
    annotations: { }
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    name: ""

  podAnnotations: { }

  podSecurityContext: { }
    # fsGroup: 2000

  securityContext: { }
    # capabilities:
    #   drop:
    #   - ALL
    # readOnlyRootFilesystem: true
    # runAsNonRoot: true
    # runAsUser: 1000

  service:
      type: ClusterIP
      port: 4433

  ingress:
    public:
      enabled: false
      annotations:
        nginx.ingress.kubernetes.io/rewrite-target: /$2
      hosts: []
#        - host: "auth.hangar.test"
#          paths:
#            - path: "/kratos(/|$)(.*)"
#              pathType: ImplementationSpecific

  resources: { }
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi

  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 100
    targetCPUUtilizationPercentage: 80
    # targetMemoryUtilizationPercentage: 80

  nodeSelector: { }

  tolerations: [ ]

  affinity: { }

  config:
    # todo abstract out values from the configmap, then abstract common values across all services
