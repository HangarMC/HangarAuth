/*
 * Ory Hydra API
 * Documentation for all of Ory Hydra's APIs.
 *
 * The version of the OpenAPI document: v1.11.8
 * Contact: hi@ory.sh
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
// TODO remove me when https://github.com/ory/sdk/pull/192 is merged

package sh.ory.hydra.api;

import com.google.gson.reflect.TypeToken;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import sh.ory.hydra.ApiCallback;
import sh.ory.hydra.ApiClient;
import sh.ory.hydra.ApiException;
import sh.ory.hydra.ApiResponse;
import sh.ory.hydra.Configuration;
import sh.ory.hydra.Pair;
import sh.ory.hydra.model.AcceptConsentRequest;
import sh.ory.hydra.model.AcceptLoginRequest;
import sh.ory.hydra.model.CompletedRequest;
import sh.ory.hydra.model.ConsentRequest;
import sh.ory.hydra.model.FlushInactiveOAuth2TokensRequest;
import sh.ory.hydra.model.JSONWebKey;
import sh.ory.hydra.model.JSONWebKeySet;
import sh.ory.hydra.model.JsonWebKeySetGeneratorRequest;
import sh.ory.hydra.model.LoginRequest;
import sh.ory.hydra.model.LogoutRequest;
import sh.ory.hydra.model.OAuth2Client;
import sh.ory.hydra.model.OAuth2TokenIntrospection;
import sh.ory.hydra.model.PatchDocument;
import sh.ory.hydra.model.PreviousConsentSession;
import sh.ory.hydra.model.RejectRequest;
import sh.ory.hydra.model.TrustJwtGrantIssuerBody;
import sh.ory.hydra.model.TrustedJwtGrantIssuer;

public class AdminApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public AdminApi() {
        this(Configuration.getDefaultApiClient());
    }

    public AdminApi(final ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return this.localVarApiClient;
    }

    public void setApiClient(final ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return this.localHostIndex;
    }

    public void setHostIndex(final int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return this.localCustomBaseUrl;
    }

    public void setCustomBaseUrl(final String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for acceptConsentRequest
     *
     * @param consentChallenge     (required)
     * @param acceptConsentRequest (optional)
     * @param _callback            Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> completedRequest </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call acceptConsentRequestCall(final String consentChallenge, final AcceptConsentRequest acceptConsentRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        final String[] localBasePaths = new String[]{};

        // Determine Base Path to Use
        if (this.localCustomBaseUrl != null) {
            basePath = this.localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[this.localHostIndex];
        } else {
            basePath = null;
        }

        final Object localVarPostBody = acceptConsentRequest;

        // create path and map variables
        final String localVarPath = "/oauth2/auth/requests/consent/accept";

        final List<Pair> localVarQueryParams = new ArrayList<>();
        final List<Pair> localVarCollectionQueryParams = new ArrayList<>();
        final Map<String, String> localVarHeaderParams = new HashMap<>();
        final Map<String, String> localVarCookieParams = new HashMap<>();
        final Map<String, Object> localVarFormParams = new HashMap<>();

        if (consentChallenge != null) {
            localVarQueryParams.addAll(this.localVarApiClient.parameterToPair("consent_challenge", consentChallenge));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = this.localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = this.localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        final String[] localVarAuthNames = new String[]{};
        return this.localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call acceptConsentRequestValidateBeforeCall(final String consentChallenge, final AcceptConsentRequest acceptConsentRequest, final ApiCallback _callback) throws ApiException {

        // verify the required parameter 'consentChallenge' is set
        if (consentChallenge == null) {
            throw new ApiException("Missing the required parameter 'consentChallenge' when calling acceptConsentRequest(Async)");
        }


        final okhttp3.Call localVarCall = this.acceptConsentRequestCall(consentChallenge, acceptConsentRequest, _callback);
        return localVarCall;

    }

    /**
     * Accept a Consent Request When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra
     * asks the login provider to authenticate the subject and then tell ORY Hydra now about it. If the subject
     * authenticated, he/she must now be asked if the OAuth 2.0 Client which initiated the flow should be allowed to
     * access the resources on the subject&#39;s behalf.  The consent provider which handles this request and is a web
     * app implemented and hosted by you. It shows a subject interface which asks the subject to grant or deny the
     * client access to the requested scope (\&quot;Application my-dropbox-app wants write access to all your private
     * files\&quot;).  The consent challenge is appended to the consent provider&#39;s URL to which the subject&#39;s
     * user-agent (browser) is redirected to. The consent provider uses that challenge to fetch information on the
     * OAuth2 request and then tells ORY Hydra if the subject accepted or rejected the request.  This endpoint tells ORY
     * Hydra that the subject has authorized the OAuth 2.0 client to access resources on his/her behalf. The consent
     * provider includes additional information, such as session data for access and ID tokens, and if the consent
     * request should be used as basis for future requests.  The response contains a redirect URL which the consent
     * provider should redirect the user-agent to.
     *
     * @param consentChallenge     (required)
     * @param acceptConsentRequest (optional)
     * @return CompletedRequest
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> completedRequest </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public CompletedRequest acceptConsentRequest(final String consentChallenge, final AcceptConsentRequest acceptConsentRequest) throws ApiException {
        final ApiResponse<CompletedRequest> localVarResp = this.acceptConsentRequestWithHttpInfo(consentChallenge, acceptConsentRequest);
        return localVarResp.getData();
    }

    /**
     * Accept a Consent Request When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra
     * asks the login provider to authenticate the subject and then tell ORY Hydra now about it. If the subject
     * authenticated, he/she must now be asked if the OAuth 2.0 Client which initiated the flow should be allowed to
     * access the resources on the subject&#39;s behalf.  The consent provider which handles this request and is a web
     * app implemented and hosted by you. It shows a subject interface which asks the subject to grant or deny the
     * client access to the requested scope (\&quot;Application my-dropbox-app wants write access to all your private
     * files\&quot;).  The consent challenge is appended to the consent provider&#39;s URL to which the subject&#39;s
     * user-agent (browser) is redirected to. The consent provider uses that challenge to fetch information on the
     * OAuth2 request and then tells ORY Hydra if the subject accepted or rejected the request.  This endpoint tells ORY
     * Hydra that the subject has authorized the OAuth 2.0 client to access resources on his/her behalf. The consent
     * provider includes additional information, such as session data for access and ID tokens, and if the consent
     * request should be used as basis for future requests.  The response contains a redirect URL which the consent
     * provider should redirect the user-agent to.
     *
     * @param consentChallenge     (required)
     * @param acceptConsentRequest (optional)
     * @return ApiResponse&lt;CompletedRequest&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> completedRequest </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<CompletedRequest> acceptConsentRequestWithHttpInfo(final String consentChallenge, final AcceptConsentRequest acceptConsentRequest) throws ApiException {
        final okhttp3.Call localVarCall = this.acceptConsentRequestValidateBeforeCall(consentChallenge, acceptConsentRequest, null);
        final Type localVarReturnType = new TypeToken<CompletedRequest>() {
        }.getType();
        return this.localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Accept a Consent Request (asynchronously) When an authorization code, hybrid, or implicit OAuth 2.0 Flow is
     * initiated, ORY Hydra asks the login provider to authenticate the subject and then tell ORY Hydra now about it. If
     * the subject authenticated, he/she must now be asked if the OAuth 2.0 Client which initiated the flow should be
     * allowed to access the resources on the subject&#39;s behalf.  The consent provider which handles this request and
     * is a web app implemented and hosted by you. It shows a subject interface which asks the subject to grant or deny
     * the client access to the requested scope (\&quot;Application my-dropbox-app wants write access to all your
     * private files\&quot;).  The consent challenge is appended to the consent provider&#39;s URL to which the
     * subject&#39;s user-agent (browser) is redirected to. The consent provider uses that challenge to fetch
     * information on the OAuth2 request and then tells ORY Hydra if the subject accepted or rejected the request.  This
     * endpoint tells ORY Hydra that the subject has authorized the OAuth 2.0 client to access resources on his/her
     * behalf. The consent provider includes additional information, such as session data for access and ID tokens, and
     * if the consent request should be used as basis for future requests.  The response contains a redirect URL which
     * the consent provider should redirect the user-agent to.
     *
     * @param consentChallenge     (required)
     * @param acceptConsentRequest (optional)
     * @param _callback            The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> completedRequest </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call acceptConsentRequestAsync(final String consentChallenge, final AcceptConsentRequest acceptConsentRequest, final ApiCallback<CompletedRequest> _callback) throws ApiException {

        final okhttp3.Call localVarCall = this.acceptConsentRequestValidateBeforeCall(consentChallenge, acceptConsentRequest, _callback);
        final Type localVarReturnType = new TypeToken<CompletedRequest>() {
        }.getType();
        this.localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    /**
     * Build call for acceptLoginRequest
     *
     * @param loginChallenge     (required)
     * @param acceptLoginRequest (optional)
     * @param _callback          Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> completedRequest </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call acceptLoginRequestCall(final String loginChallenge, final AcceptLoginRequest acceptLoginRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        final String[] localBasePaths = new String[]{};

        // Determine Base Path to Use
        if (this.localCustomBaseUrl != null) {
            basePath = this.localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[this.localHostIndex];
        } else {
            basePath = null;
        }

        final Object localVarPostBody = acceptLoginRequest;

        // create path and map variables
        final String localVarPath = "/oauth2/auth/requests/login/accept";

        final List<Pair> localVarQueryParams = new ArrayList<>();
        final List<Pair> localVarCollectionQueryParams = new ArrayList<>();
        final Map<String, String> localVarHeaderParams = new HashMap<>();
        final Map<String, String> localVarCookieParams = new HashMap<>();
        final Map<String, Object> localVarFormParams = new HashMap<>();

        if (loginChallenge != null) {
            localVarQueryParams.addAll(this.localVarApiClient.parameterToPair("login_challenge", loginChallenge));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = this.localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = this.localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        final String[] localVarAuthNames = new String[]{};
        return this.localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call acceptLoginRequestValidateBeforeCall(final String loginChallenge, final AcceptLoginRequest acceptLoginRequest, final ApiCallback _callback) throws ApiException {

        // verify the required parameter 'loginChallenge' is set
        if (loginChallenge == null) {
            throw new ApiException("Missing the required parameter 'loginChallenge' when calling acceptLoginRequest(Async)");
        }


        final okhttp3.Call localVarCall = this.acceptLoginRequestCall(loginChallenge, acceptLoginRequest, _callback);
        return localVarCall;

    }

    /**
     * Accept a Login Request When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra
     * asks the login provider (sometimes called \&quot;identity provider\&quot;) to authenticate the subject and then
     * tell ORY Hydra now about it. The login provider is an web-app you write and host, and it must be able to
     * authenticate (\&quot;show the subject a login screen\&quot;) a subject (in OAuth2 the proper name for subject is
     * \&quot;resource owner\&quot;).  The authentication challenge is appended to the login provider URL to which the
     * subject&#39;s user-agent (browser) is redirected to. The login provider uses that challenge to fetch information
     * on the OAuth2 request and then accept or reject the requested authentication process.  This endpoint tells ORY
     * Hydra that the subject has successfully authenticated and includes additional information such as the
     * subject&#39;s ID and if ORY Hydra should remember the subject&#39;s subject agent for future authentication
     * attempts by setting a cookie.  The response contains a redirect URL which the login provider should redirect the
     * user-agent to.
     *
     * @param loginChallenge     (required)
     * @param acceptLoginRequest (optional)
     * @return CompletedRequest
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> completedRequest </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public CompletedRequest acceptLoginRequest(final String loginChallenge, final AcceptLoginRequest acceptLoginRequest) throws ApiException {
        final ApiResponse<CompletedRequest> localVarResp = this.acceptLoginRequestWithHttpInfo(loginChallenge, acceptLoginRequest);
        return localVarResp.getData();
    }

    /**
     * Accept a Login Request When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra
     * asks the login provider (sometimes called \&quot;identity provider\&quot;) to authenticate the subject and then
     * tell ORY Hydra now about it. The login provider is an web-app you write and host, and it must be able to
     * authenticate (\&quot;show the subject a login screen\&quot;) a subject (in OAuth2 the proper name for subject is
     * \&quot;resource owner\&quot;).  The authentication challenge is appended to the login provider URL to which the
     * subject&#39;s user-agent (browser) is redirected to. The login provider uses that challenge to fetch information
     * on the OAuth2 request and then accept or reject the requested authentication process.  This endpoint tells ORY
     * Hydra that the subject has successfully authenticated and includes additional information such as the
     * subject&#39;s ID and if ORY Hydra should remember the subject&#39;s subject agent for future authentication
     * attempts by setting a cookie.  The response contains a redirect URL which the login provider should redirect the
     * user-agent to.
     *
     * @param loginChallenge     (required)
     * @param acceptLoginRequest (optional)
     * @return ApiResponse&lt;CompletedRequest&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> completedRequest </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<CompletedRequest> acceptLoginRequestWithHttpInfo(final String loginChallenge, final AcceptLoginRequest acceptLoginRequest) throws ApiException {
        final okhttp3.Call localVarCall = this.acceptLoginRequestValidateBeforeCall(loginChallenge, acceptLoginRequest, null);
        final Type localVarReturnType = new TypeToken<CompletedRequest>() {
        }.getType();
        return this.localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Accept a Login Request (asynchronously) When an authorization code, hybrid, or implicit OAuth 2.0 Flow is
     * initiated, ORY Hydra asks the login provider (sometimes called \&quot;identity provider\&quot;) to authenticate
     * the subject and then tell ORY Hydra now about it. The login provider is an web-app you write and host, and it
     * must be able to authenticate (\&quot;show the subject a login screen\&quot;) a subject (in OAuth2 the proper name
     * for subject is \&quot;resource owner\&quot;).  The authentication challenge is appended to the login provider URL
     * to which the subject&#39;s user-agent (browser) is redirected to. The login provider uses that challenge to fetch
     * information on the OAuth2 request and then accept or reject the requested authentication process.  This endpoint
     * tells ORY Hydra that the subject has successfully authenticated and includes additional information such as the
     * subject&#39;s ID and if ORY Hydra should remember the subject&#39;s subject agent for future authentication
     * attempts by setting a cookie.  The response contains a redirect URL which the login provider should redirect the
     * user-agent to.
     *
     * @param loginChallenge     (required)
     * @param acceptLoginRequest (optional)
     * @param _callback          The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> completedRequest </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call acceptLoginRequestAsync(final String loginChallenge, final AcceptLoginRequest acceptLoginRequest, final ApiCallback<CompletedRequest> _callback) throws ApiException {

        final okhttp3.Call localVarCall = this.acceptLoginRequestValidateBeforeCall(loginChallenge, acceptLoginRequest, _callback);
        final Type localVarReturnType = new TypeToken<CompletedRequest>() {
        }.getType();
        this.localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    /**
     * Build call for acceptLogoutRequest
     *
     * @param logoutChallenge (required)
     * @param _callback       Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> completedRequest </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call acceptLogoutRequestCall(final String logoutChallenge, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        final String[] localBasePaths = new String[]{};

        // Determine Base Path to Use
        if (this.localCustomBaseUrl != null) {
            basePath = this.localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[this.localHostIndex];
        } else {
            basePath = null;
        }

        final Object localVarPostBody = null;

        // create path and map variables
        final String localVarPath = "/oauth2/auth/requests/logout/accept";

        final List<Pair> localVarQueryParams = new ArrayList<>();
        final List<Pair> localVarCollectionQueryParams = new ArrayList<>();
        final Map<String, String> localVarHeaderParams = new HashMap<>();
        final Map<String, String> localVarCookieParams = new HashMap<>();
        final Map<String, Object> localVarFormParams = new HashMap<>();

        if (logoutChallenge != null) {
            localVarQueryParams.addAll(this.localVarApiClient.parameterToPair("logout_challenge", logoutChallenge));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = this.localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json" // TODO hack
        };
        final String localVarContentType = this.localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        final String[] localVarAuthNames = new String[]{};
        return this.localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call acceptLogoutRequestValidateBeforeCall(final String logoutChallenge, final ApiCallback _callback) throws ApiException {

        // verify the required parameter 'logoutChallenge' is set
        if (logoutChallenge == null) {
            throw new ApiException("Missing the required parameter 'logoutChallenge' when calling acceptLogoutRequest(Async)");
        }


        final okhttp3.Call localVarCall = this.acceptLogoutRequestCall(logoutChallenge, _callback);
        return localVarCall;

    }

    /**
     * Accept a Logout Request When a user or an application requests ORY Hydra to log out a user, this endpoint is used
     * to confirm that logout request. No body is required.  The response contains a redirect URL which the consent
     * provider should redirect the user-agent to.
     *
     * @param logoutChallenge (required)
     * @return CompletedRequest
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> completedRequest </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public CompletedRequest acceptLogoutRequest(final String logoutChallenge) throws ApiException {
        final ApiResponse<CompletedRequest> localVarResp = this.acceptLogoutRequestWithHttpInfo(logoutChallenge);
        return localVarResp.getData();
    }

    /**
     * Accept a Logout Request When a user or an application requests ORY Hydra to log out a user, this endpoint is used
     * to confirm that logout request. No body is required.  The response contains a redirect URL which the consent
     * provider should redirect the user-agent to.
     *
     * @param logoutChallenge (required)
     * @return ApiResponse&lt;CompletedRequest&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> completedRequest </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<CompletedRequest> acceptLogoutRequestWithHttpInfo(final String logoutChallenge) throws ApiException {
        final okhttp3.Call localVarCall = this.acceptLogoutRequestValidateBeforeCall(logoutChallenge, null);
        final Type localVarReturnType = new TypeToken<CompletedRequest>() {
        }.getType();
        return this.localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Accept a Logout Request (asynchronously) When a user or an application requests ORY Hydra to log out a user, this
     * endpoint is used to confirm that logout request. No body is required.  The response contains a redirect URL which
     * the consent provider should redirect the user-agent to.
     *
     * @param logoutChallenge (required)
     * @param _callback       The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> completedRequest </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call acceptLogoutRequestAsync(final String logoutChallenge, final ApiCallback<CompletedRequest> _callback) throws ApiException {

        final okhttp3.Call localVarCall = this.acceptLogoutRequestValidateBeforeCall(logoutChallenge, _callback);
        final Type localVarReturnType = new TypeToken<CompletedRequest>() {
        }.getType();
        this.localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    /**
     * Build call for createJsonWebKeySet
     *
     * @param set                           The set (required)
     * @param jsonWebKeySetGeneratorRequest (optional)
     * @param _callback                     Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 201 </td><td> JSONWebKeySet </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call createJsonWebKeySetCall(final String set, final JsonWebKeySetGeneratorRequest jsonWebKeySetGeneratorRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        final String[] localBasePaths = new String[]{};

        // Determine Base Path to Use
        if (this.localCustomBaseUrl != null) {
            basePath = this.localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[this.localHostIndex];
        } else {
            basePath = null;
        }

        final Object localVarPostBody = jsonWebKeySetGeneratorRequest;

        // create path and map variables
        final String localVarPath = "/keys/{set}"
            .replaceAll("\\{" + "set" + "\\}", this.localVarApiClient.escapeString(set));

        final List<Pair> localVarQueryParams = new ArrayList<>();
        final List<Pair> localVarCollectionQueryParams = new ArrayList<>();
        final Map<String, String> localVarHeaderParams = new HashMap<>();
        final Map<String, String> localVarCookieParams = new HashMap<>();
        final Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = this.localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = this.localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        final String[] localVarAuthNames = new String[]{};
        return this.localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createJsonWebKeySetValidateBeforeCall(final String set, final JsonWebKeySetGeneratorRequest jsonWebKeySetGeneratorRequest, final ApiCallback _callback) throws ApiException {

        // verify the required parameter 'set' is set
        if (set == null) {
            throw new ApiException("Missing the required parameter 'set' when calling createJsonWebKeySet(Async)");
        }


        final okhttp3.Call localVarCall = this.createJsonWebKeySetCall(set, jsonWebKeySetGeneratorRequest, _callback);
        return localVarCall;

    }

    /**
     * Generate a New JSON Web Key This endpoint is capable of generating JSON Web Key Sets for you. There a different
     * strategies available, such as symmetric cryptographic keys (HS256, HS512) and asymetric cryptographic keys
     * (RS256, ECDSA). If the specified JSON Web Key Set does not exist, it will be created.  A JSON Web Key (JWK) is a
     * JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data
     * structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this
     * functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens),
     * and allows storing user-defined keys as well.
     *
     * @param set                           The set (required)
     * @param jsonWebKeySetGeneratorRequest (optional)
     * @return JSONWebKeySet
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 201 </td><td> JSONWebKeySet </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public JSONWebKeySet createJsonWebKeySet(final String set, final JsonWebKeySetGeneratorRequest jsonWebKeySetGeneratorRequest) throws ApiException {
        final ApiResponse<JSONWebKeySet> localVarResp = this.createJsonWebKeySetWithHttpInfo(set, jsonWebKeySetGeneratorRequest);
        return localVarResp.getData();
    }

    /**
     * Generate a New JSON Web Key This endpoint is capable of generating JSON Web Key Sets for you. There a different
     * strategies available, such as symmetric cryptographic keys (HS256, HS512) and asymetric cryptographic keys
     * (RS256, ECDSA). If the specified JSON Web Key Set does not exist, it will be created.  A JSON Web Key (JWK) is a
     * JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data
     * structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this
     * functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens),
     * and allows storing user-defined keys as well.
     *
     * @param set                           The set (required)
     * @param jsonWebKeySetGeneratorRequest (optional)
     * @return ApiResponse&lt;JSONWebKeySet&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 201 </td><td> JSONWebKeySet </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<JSONWebKeySet> createJsonWebKeySetWithHttpInfo(final String set, final JsonWebKeySetGeneratorRequest jsonWebKeySetGeneratorRequest) throws ApiException {
        final okhttp3.Call localVarCall = this.createJsonWebKeySetValidateBeforeCall(set, jsonWebKeySetGeneratorRequest, null);
        final Type localVarReturnType = new TypeToken<JSONWebKeySet>() {
        }.getType();
        return this.localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Generate a New JSON Web Key (asynchronously) This endpoint is capable of generating JSON Web Key Sets for you.
     * There a different strategies available, such as symmetric cryptographic keys (HS256, HS512) and asymetric
     * cryptographic keys (RS256, ECDSA). If the specified JSON Web Key Set does not exist, it will be created.  A JSON
     * Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK
     * Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id.
     * ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID
     * Connect ID tokens), and allows storing user-defined keys as well.
     *
     * @param set                           The set (required)
     * @param jsonWebKeySetGeneratorRequest (optional)
     * @param _callback                     The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 201 </td><td> JSONWebKeySet </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call createJsonWebKeySetAsync(final String set, final JsonWebKeySetGeneratorRequest jsonWebKeySetGeneratorRequest, final ApiCallback<JSONWebKeySet> _callback) throws ApiException {

        final okhttp3.Call localVarCall = this.createJsonWebKeySetValidateBeforeCall(set, jsonWebKeySetGeneratorRequest, _callback);
        final Type localVarReturnType = new TypeToken<JSONWebKeySet>() {
        }.getType();
        this.localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    /**
     * Build call for createOAuth2Client
     *
     * @param oauth2Client (required)
     * @param _callback    Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 201 </td><td> oAuth2Client </td><td>  -  </td></tr>
     * <tr><td> 0 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call createOAuth2ClientCall(final OAuth2Client oauth2Client, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        final String[] localBasePaths = new String[]{};

        // Determine Base Path to Use
        if (this.localCustomBaseUrl != null) {
            basePath = this.localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[this.localHostIndex];
        } else {
            basePath = null;
        }

        final Object localVarPostBody = oauth2Client;

        // create path and map variables
        final String localVarPath = "/clients";

        final List<Pair> localVarQueryParams = new ArrayList<>();
        final List<Pair> localVarCollectionQueryParams = new ArrayList<>();
        final Map<String, String> localVarHeaderParams = new HashMap<>();
        final Map<String, String> localVarCookieParams = new HashMap<>();
        final Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = this.localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = this.localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        final String[] localVarAuthNames = new String[]{};
        return this.localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createOAuth2ClientValidateBeforeCall(final OAuth2Client oauth2Client, final ApiCallback _callback) throws ApiException {

        // verify the required parameter 'oauth2Client' is set
        if (oauth2Client == null) {
            throw new ApiException("Missing the required parameter 'oauth2Client' when calling createOAuth2Client(Async)");
        }


        final okhttp3.Call localVarCall = this.createOAuth2ClientCall(oauth2Client, _callback);
        return localVarCall;

    }

    /**
     * Create an OAuth 2.0 Client Create a new OAuth 2.0 client If you pass &#x60;client_secret&#x60; the secret will be
     * used, otherwise a random secret will be generated. The secret will be returned in the response and you will not
     * be able to retrieve it later on. Write the secret down and keep it somwhere safe.  OAuth 2.0 clients are used to
     * perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want
     * to consume your OAuth 2.0 or OpenID Connect capabilities.
     *
     * @param oauth2Client (required)
     * @return OAuth2Client
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 201 </td><td> oAuth2Client </td><td>  -  </td></tr>
     * <tr><td> 0 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public OAuth2Client createOAuth2Client(final OAuth2Client oauth2Client) throws ApiException {
        final ApiResponse<OAuth2Client> localVarResp = this.createOAuth2ClientWithHttpInfo(oauth2Client);
        return localVarResp.getData();
    }

    /**
     * Create an OAuth 2.0 Client Create a new OAuth 2.0 client If you pass &#x60;client_secret&#x60; the secret will be
     * used, otherwise a random secret will be generated. The secret will be returned in the response and you will not
     * be able to retrieve it later on. Write the secret down and keep it somwhere safe.  OAuth 2.0 clients are used to
     * perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want
     * to consume your OAuth 2.0 or OpenID Connect capabilities.
     *
     * @param oauth2Client (required)
     * @return ApiResponse&lt;OAuth2Client&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 201 </td><td> oAuth2Client </td><td>  -  </td></tr>
     * <tr><td> 0 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<OAuth2Client> createOAuth2ClientWithHttpInfo(final OAuth2Client oauth2Client) throws ApiException {
        final okhttp3.Call localVarCall = this.createOAuth2ClientValidateBeforeCall(oauth2Client, null);
        final Type localVarReturnType = new TypeToken<OAuth2Client>() {
        }.getType();
        return this.localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create an OAuth 2.0 Client (asynchronously) Create a new OAuth 2.0 client If you pass &#x60;client_secret&#x60;
     * the secret will be used, otherwise a random secret will be generated. The secret will be returned in the response
     * and you will not be able to retrieve it later on. Write the secret down and keep it somwhere safe.  OAuth 2.0
     * clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for
     * applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
     *
     * @param oauth2Client (required)
     * @param _callback    The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 201 </td><td> oAuth2Client </td><td>  -  </td></tr>
     * <tr><td> 0 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call createOAuth2ClientAsync(final OAuth2Client oauth2Client, final ApiCallback<OAuth2Client> _callback) throws ApiException {

        final okhttp3.Call localVarCall = this.createOAuth2ClientValidateBeforeCall(oauth2Client, _callback);
        final Type localVarReturnType = new TypeToken<OAuth2Client>() {
        }.getType();
        this.localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    /**
     * Build call for deleteJsonWebKey
     *
     * @param kid       The kid of the desired key (required)
     * @param set       The set (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Empty responses are sent when, for example, resources are deleted. The HTTP status code
     * for empty responses is typically 201. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deleteJsonWebKeyCall(final String kid, final String set, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        final String[] localBasePaths = new String[]{};

        // Determine Base Path to Use
        if (this.localCustomBaseUrl != null) {
            basePath = this.localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[this.localHostIndex];
        } else {
            basePath = null;
        }

        final Object localVarPostBody = null;

        // create path and map variables
        final String localVarPath = "/keys/{set}/{kid}"
            .replaceAll("\\{" + "kid" + "\\}", this.localVarApiClient.escapeString(kid))
            .replaceAll("\\{" + "set" + "\\}", this.localVarApiClient.escapeString(set));

        final List<Pair> localVarQueryParams = new ArrayList<>();
        final List<Pair> localVarCollectionQueryParams = new ArrayList<>();
        final Map<String, String> localVarHeaderParams = new HashMap<>();
        final Map<String, String> localVarCookieParams = new HashMap<>();
        final Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = this.localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = this.localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        final String[] localVarAuthNames = new String[]{};
        return this.localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteJsonWebKeyValidateBeforeCall(final String kid, final String set, final ApiCallback _callback) throws ApiException {

        // verify the required parameter 'kid' is set
        if (kid == null) {
            throw new ApiException("Missing the required parameter 'kid' when calling deleteJsonWebKey(Async)");
        }

        // verify the required parameter 'set' is set
        if (set == null) {
            throw new ApiException("Missing the required parameter 'set' when calling deleteJsonWebKey(Async)");
        }


        final okhttp3.Call localVarCall = this.deleteJsonWebKeyCall(kid, set, _callback);
        return localVarCall;

    }

    /**
     * Delete a JSON Web Key Use this endpoint to delete a single JSON Web Key.  A JSON Web Key (JWK) is a JavaScript
     * Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure
     * that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this
     * functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens),
     * and allows storing user-defined keys as well.
     *
     * @param kid The kid of the desired key (required)
     * @param set The set (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Empty responses are sent when, for example, resources are deleted. The HTTP status code
     * for empty responses is typically 201. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public void deleteJsonWebKey(final String kid, final String set) throws ApiException {
        this.deleteJsonWebKeyWithHttpInfo(kid, set);
    }

    /**
     * Delete a JSON Web Key Use this endpoint to delete a single JSON Web Key.  A JSON Web Key (JWK) is a JavaScript
     * Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON data structure
     * that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses this
     * functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID tokens),
     * and allows storing user-defined keys as well.
     *
     * @param kid The kid of the desired key (required)
     * @param set The set (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Empty responses are sent when, for example, resources are deleted. The HTTP status code
     * for empty responses is typically 201. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> deleteJsonWebKeyWithHttpInfo(final String kid, final String set) throws ApiException {
        final okhttp3.Call localVarCall = this.deleteJsonWebKeyValidateBeforeCall(kid, set, null);
        return this.localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete a JSON Web Key (asynchronously) Use this endpoint to delete a single JSON Web Key.  A JSON Web Key (JWK)
     * is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a JSON
     * data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra uses
     * this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID
     * tokens), and allows storing user-defined keys as well.
     *
     * @param kid       The kid of the desired key (required)
     * @param set       The set (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Empty responses are sent when, for example, resources are deleted. The HTTP status code
     * for empty responses is typically 201. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deleteJsonWebKeyAsync(final String kid, final String set, final ApiCallback<Void> _callback) throws ApiException {

        final okhttp3.Call localVarCall = this.deleteJsonWebKeyValidateBeforeCall(kid, set, _callback);
        this.localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    /**
     * Build call for deleteJsonWebKeySet
     *
     * @param set       The set (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Empty responses are sent when, for example, resources are deleted. The HTTP status code
     * for empty responses is typically 201. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deleteJsonWebKeySetCall(final String set, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        final String[] localBasePaths = new String[]{};

        // Determine Base Path to Use
        if (this.localCustomBaseUrl != null) {
            basePath = this.localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[this.localHostIndex];
        } else {
            basePath = null;
        }

        final Object localVarPostBody = null;

        // create path and map variables
        final String localVarPath = "/keys/{set}"
            .replaceAll("\\{" + "set" + "\\}", this.localVarApiClient.escapeString(set));

        final List<Pair> localVarQueryParams = new ArrayList<>();
        final List<Pair> localVarCollectionQueryParams = new ArrayList<>();
        final Map<String, String> localVarHeaderParams = new HashMap<>();
        final Map<String, String> localVarCookieParams = new HashMap<>();
        final Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = this.localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = this.localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        final String[] localVarAuthNames = new String[]{};
        return this.localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteJsonWebKeySetValidateBeforeCall(final String set, final ApiCallback _callback) throws ApiException {

        // verify the required parameter 'set' is set
        if (set == null) {
            throw new ApiException("Missing the required parameter 'set' when calling deleteJsonWebKeySet(Async)");
        }


        final okhttp3.Call localVarCall = this.deleteJsonWebKeySetCall(set, _callback);
        return localVarCall;

    }

    /**
     * Delete a JSON Web Key Set Use this endpoint to delete a complete JSON Web Key Set and all the keys in that set.
     * A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A
     * JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key
     * id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as
     * OpenID Connect ID tokens), and allows storing user-defined keys as well.
     *
     * @param set The set (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Empty responses are sent when, for example, resources are deleted. The HTTP status code
     * for empty responses is typically 201. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public void deleteJsonWebKeySet(final String set) throws ApiException {
        this.deleteJsonWebKeySetWithHttpInfo(set);
    }

    /**
     * Delete a JSON Web Key Set Use this endpoint to delete a complete JSON Web Key Set and all the keys in that set.
     * A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A
     * JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key
     * id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as
     * OpenID Connect ID tokens), and allows storing user-defined keys as well.
     *
     * @param set The set (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Empty responses are sent when, for example, resources are deleted. The HTTP status code
     * for empty responses is typically 201. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> deleteJsonWebKeySetWithHttpInfo(final String set) throws ApiException {
        final okhttp3.Call localVarCall = this.deleteJsonWebKeySetValidateBeforeCall(set, null);
        return this.localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete a JSON Web Key Set (asynchronously) Use this endpoint to delete a complete JSON Web Key Set and all the
     * keys in that set.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a
     * cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified
     * by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web
     * Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
     *
     * @param set       The set (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Empty responses are sent when, for example, resources are deleted. The HTTP status code
     * for empty responses is typically 201. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deleteJsonWebKeySetAsync(final String set, final ApiCallback<Void> _callback) throws ApiException {

        final okhttp3.Call localVarCall = this.deleteJsonWebKeySetValidateBeforeCall(set, _callback);
        this.localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    /**
     * Build call for deleteOAuth2Client
     *
     * @param id        The id of the OAuth 2.0 Client. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Empty responses are sent when, for example, resources are deleted. The HTTP status code
     * for empty responses is typically 201. </td><td>  -  </td></tr>
     * <tr><td> 0 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deleteOAuth2ClientCall(final String id, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        final String[] localBasePaths = new String[]{};

        // Determine Base Path to Use
        if (this.localCustomBaseUrl != null) {
            basePath = this.localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[this.localHostIndex];
        } else {
            basePath = null;
        }

        final Object localVarPostBody = null;

        // create path and map variables
        final String localVarPath = "/clients/{id}"
            .replaceAll("\\{" + "id" + "\\}", this.localVarApiClient.escapeString(id));

        final List<Pair> localVarQueryParams = new ArrayList<>();
        final List<Pair> localVarCollectionQueryParams = new ArrayList<>();
        final Map<String, String> localVarHeaderParams = new HashMap<>();
        final Map<String, String> localVarCookieParams = new HashMap<>();
        final Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = this.localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = this.localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        final String[] localVarAuthNames = new String[]{};
        return this.localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteOAuth2ClientValidateBeforeCall(final String id, final ApiCallback _callback) throws ApiException {

        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling deleteOAuth2Client(Async)");
        }


        final okhttp3.Call localVarCall = this.deleteOAuth2ClientCall(id, _callback);
        return localVarCall;

    }

    /**
     * Deletes an OAuth 2.0 Client Delete an existing OAuth 2.0 Client by its ID.  OAuth 2.0 clients are used to perform
     * OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to
     * consume your OAuth 2.0 or OpenID Connect capabilities.  Make sure that this endpoint is well protected and only
     * callable by first-party components.
     *
     * @param id The id of the OAuth 2.0 Client. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Empty responses are sent when, for example, resources are deleted. The HTTP status code
     * for empty responses is typically 201. </td><td>  -  </td></tr>
     * <tr><td> 0 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public void deleteOAuth2Client(final String id) throws ApiException {
        this.deleteOAuth2ClientWithHttpInfo(id);
    }

    /**
     * Deletes an OAuth 2.0 Client Delete an existing OAuth 2.0 Client by its ID.  OAuth 2.0 clients are used to perform
     * OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to
     * consume your OAuth 2.0 or OpenID Connect capabilities.  Make sure that this endpoint is well protected and only
     * callable by first-party components.
     *
     * @param id The id of the OAuth 2.0 Client. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Empty responses are sent when, for example, resources are deleted. The HTTP status code
     * for empty responses is typically 201. </td><td>  -  </td></tr>
     * <tr><td> 0 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> deleteOAuth2ClientWithHttpInfo(final String id) throws ApiException {
        final okhttp3.Call localVarCall = this.deleteOAuth2ClientValidateBeforeCall(id, null);
        return this.localVarApiClient.execute(localVarCall);
    }

    /**
     * Deletes an OAuth 2.0 Client (asynchronously) Delete an existing OAuth 2.0 Client by its ID.  OAuth 2.0 clients
     * are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications
     * which want to consume your OAuth 2.0 or OpenID Connect capabilities.  Make sure that this endpoint is well
     * protected and only callable by first-party components.
     *
     * @param id        The id of the OAuth 2.0 Client. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Empty responses are sent when, for example, resources are deleted. The HTTP status code
     * for empty responses is typically 201. </td><td>  -  </td></tr>
     * <tr><td> 0 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deleteOAuth2ClientAsync(final String id, final ApiCallback<Void> _callback) throws ApiException {

        final okhttp3.Call localVarCall = this.deleteOAuth2ClientValidateBeforeCall(id, _callback);
        this.localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    /**
     * Build call for deleteOAuth2Token
     *
     * @param clientId  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Empty responses are sent when, for example, resources are deleted. The HTTP status code
     * for empty responses is typically 201. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deleteOAuth2TokenCall(final String clientId, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        final String[] localBasePaths = new String[]{};

        // Determine Base Path to Use
        if (this.localCustomBaseUrl != null) {
            basePath = this.localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[this.localHostIndex];
        } else {
            basePath = null;
        }

        final Object localVarPostBody = null;

        // create path and map variables
        final String localVarPath = "/oauth2/tokens";

        final List<Pair> localVarQueryParams = new ArrayList<>();
        final List<Pair> localVarCollectionQueryParams = new ArrayList<>();
        final Map<String, String> localVarHeaderParams = new HashMap<>();
        final Map<String, String> localVarCookieParams = new HashMap<>();
        final Map<String, Object> localVarFormParams = new HashMap<>();

        if (clientId != null) {
            localVarQueryParams.addAll(this.localVarApiClient.parameterToPair("client_id", clientId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = this.localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = this.localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        final String[] localVarAuthNames = new String[]{};
        return this.localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteOAuth2TokenValidateBeforeCall(final String clientId, final ApiCallback _callback) throws ApiException {

        // verify the required parameter 'clientId' is set
        if (clientId == null) {
            throw new ApiException("Missing the required parameter 'clientId' when calling deleteOAuth2Token(Async)");
        }


        final okhttp3.Call localVarCall = this.deleteOAuth2TokenCall(clientId, _callback);
        return localVarCall;

    }

    /**
     * Delete OAuth2 Access Tokens from a Client This endpoint deletes OAuth2 access tokens issued for a client from the
     * database
     *
     * @param clientId (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Empty responses are sent when, for example, resources are deleted. The HTTP status code
     * for empty responses is typically 201. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public void deleteOAuth2Token(final String clientId) throws ApiException {
        this.deleteOAuth2TokenWithHttpInfo(clientId);
    }

    /**
     * Delete OAuth2 Access Tokens from a Client This endpoint deletes OAuth2 access tokens issued for a client from the
     * database
     *
     * @param clientId (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Empty responses are sent when, for example, resources are deleted. The HTTP status code
     * for empty responses is typically 201. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> deleteOAuth2TokenWithHttpInfo(final String clientId) throws ApiException {
        final okhttp3.Call localVarCall = this.deleteOAuth2TokenValidateBeforeCall(clientId, null);
        return this.localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete OAuth2 Access Tokens from a Client (asynchronously) This endpoint deletes OAuth2 access tokens issued for
     * a client from the database
     *
     * @param clientId  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Empty responses are sent when, for example, resources are deleted. The HTTP status code
     * for empty responses is typically 201. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deleteOAuth2TokenAsync(final String clientId, final ApiCallback<Void> _callback) throws ApiException {

        final okhttp3.Call localVarCall = this.deleteOAuth2TokenValidateBeforeCall(clientId, _callback);
        this.localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    /**
     * Build call for deleteTrustedJwtGrantIssuer
     *
     * @param id        The id of the desired grant (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Empty responses are sent when, for example, resources are deleted. The HTTP status code
     * for empty responses is typically 201. </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> genericError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> genericError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deleteTrustedJwtGrantIssuerCall(final String id, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        final String[] localBasePaths = new String[]{};

        // Determine Base Path to Use
        if (this.localCustomBaseUrl != null) {
            basePath = this.localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[this.localHostIndex];
        } else {
            basePath = null;
        }

        final Object localVarPostBody = null;

        // create path and map variables
        final String localVarPath = "/trust/grants/jwt-bearer/issuers/{id}"
            .replaceAll("\\{" + "id" + "\\}", this.localVarApiClient.escapeString(id));

        final List<Pair> localVarQueryParams = new ArrayList<>();
        final List<Pair> localVarCollectionQueryParams = new ArrayList<>();
        final Map<String, String> localVarHeaderParams = new HashMap<>();
        final Map<String, String> localVarCookieParams = new HashMap<>();
        final Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = this.localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = this.localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        final String[] localVarAuthNames = new String[]{};
        return this.localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteTrustedJwtGrantIssuerValidateBeforeCall(final String id, final ApiCallback _callback) throws ApiException {

        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling deleteTrustedJwtGrantIssuer(Async)");
        }


        final okhttp3.Call localVarCall = this.deleteTrustedJwtGrantIssuerCall(id, _callback);
        return localVarCall;

    }

    /**
     * Delete a Trusted OAuth2 JWT Bearer Grant Type Issuer Use this endpoint to delete trusted JWT Bearer Grant Type
     * Issuer. The ID is the one returned when you created the trust relationship.  Once deleted, the associated issuer
     * will no longer be able to perform the JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and
     * Authorization Grant.
     *
     * @param id The id of the desired grant (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Empty responses are sent when, for example, resources are deleted. The HTTP status code
     * for empty responses is typically 201. </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> genericError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> genericError </td><td>  -  </td></tr>
     * </table>
     */
    public void deleteTrustedJwtGrantIssuer(final String id) throws ApiException {
        this.deleteTrustedJwtGrantIssuerWithHttpInfo(id);
    }

    /**
     * Delete a Trusted OAuth2 JWT Bearer Grant Type Issuer Use this endpoint to delete trusted JWT Bearer Grant Type
     * Issuer. The ID is the one returned when you created the trust relationship.  Once deleted, the associated issuer
     * will no longer be able to perform the JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and
     * Authorization Grant.
     *
     * @param id The id of the desired grant (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Empty responses are sent when, for example, resources are deleted. The HTTP status code
     * for empty responses is typically 201. </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> genericError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> genericError </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> deleteTrustedJwtGrantIssuerWithHttpInfo(final String id) throws ApiException {
        final okhttp3.Call localVarCall = this.deleteTrustedJwtGrantIssuerValidateBeforeCall(id, null);
        return this.localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete a Trusted OAuth2 JWT Bearer Grant Type Issuer (asynchronously) Use this endpoint to delete trusted JWT
     * Bearer Grant Type Issuer. The ID is the one returned when you created the trust relationship.  Once deleted, the
     * associated issuer will no longer be able to perform the JSON Web Token (JWT) Profile for OAuth 2.0 Client
     * Authentication and Authorization Grant.
     *
     * @param id        The id of the desired grant (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Empty responses are sent when, for example, resources are deleted. The HTTP status code
     * for empty responses is typically 201. </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> genericError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> genericError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deleteTrustedJwtGrantIssuerAsync(final String id, final ApiCallback<Void> _callback) throws ApiException {

        final okhttp3.Call localVarCall = this.deleteTrustedJwtGrantIssuerValidateBeforeCall(id, _callback);
        this.localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    /**
     * Build call for flushInactiveOAuth2Tokens
     *
     * @param flushInactiveOAuth2TokensRequest (optional)
     * @param _callback                        Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Empty responses are sent when, for example, resources are deleted. The HTTP status code
     * for empty responses is typically 201. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call flushInactiveOAuth2TokensCall(final FlushInactiveOAuth2TokensRequest flushInactiveOAuth2TokensRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        final String[] localBasePaths = new String[]{};

        // Determine Base Path to Use
        if (this.localCustomBaseUrl != null) {
            basePath = this.localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[this.localHostIndex];
        } else {
            basePath = null;
        }

        final Object localVarPostBody = flushInactiveOAuth2TokensRequest;

        // create path and map variables
        final String localVarPath = "/oauth2/flush";

        final List<Pair> localVarQueryParams = new ArrayList<>();
        final List<Pair> localVarCollectionQueryParams = new ArrayList<>();
        final Map<String, String> localVarHeaderParams = new HashMap<>();
        final Map<String, String> localVarCookieParams = new HashMap<>();
        final Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = this.localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = this.localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        final String[] localVarAuthNames = new String[]{};
        return this.localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call flushInactiveOAuth2TokensValidateBeforeCall(final FlushInactiveOAuth2TokensRequest flushInactiveOAuth2TokensRequest, final ApiCallback _callback) throws ApiException {


        final okhttp3.Call localVarCall = this.flushInactiveOAuth2TokensCall(flushInactiveOAuth2TokensRequest, _callback);
        return localVarCall;

    }

    /**
     * Flush Expired OAuth2 Access Tokens This endpoint flushes expired OAuth2 access tokens from the database. You can
     * set a time after which no tokens will be not be touched, in case you want to keep recent tokens for auditing.
     * Refresh tokens can not be flushed as they are deleted automatically when performing the refresh flow.
     *
     * @param flushInactiveOAuth2TokensRequest (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Empty responses are sent when, for example, resources are deleted. The HTTP status code
     * for empty responses is typically 201. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public void flushInactiveOAuth2Tokens(final FlushInactiveOAuth2TokensRequest flushInactiveOAuth2TokensRequest) throws ApiException {
        this.flushInactiveOAuth2TokensWithHttpInfo(flushInactiveOAuth2TokensRequest);
    }

    /**
     * Flush Expired OAuth2 Access Tokens This endpoint flushes expired OAuth2 access tokens from the database. You can
     * set a time after which no tokens will be not be touched, in case you want to keep recent tokens for auditing.
     * Refresh tokens can not be flushed as they are deleted automatically when performing the refresh flow.
     *
     * @param flushInactiveOAuth2TokensRequest (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Empty responses are sent when, for example, resources are deleted. The HTTP status code
     * for empty responses is typically 201. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> flushInactiveOAuth2TokensWithHttpInfo(final FlushInactiveOAuth2TokensRequest flushInactiveOAuth2TokensRequest) throws ApiException {
        final okhttp3.Call localVarCall = this.flushInactiveOAuth2TokensValidateBeforeCall(flushInactiveOAuth2TokensRequest, null);
        return this.localVarApiClient.execute(localVarCall);
    }

    /**
     * Flush Expired OAuth2 Access Tokens (asynchronously) This endpoint flushes expired OAuth2 access tokens from the
     * database. You can set a time after which no tokens will be not be touched, in case you want to keep recent tokens
     * for auditing. Refresh tokens can not be flushed as they are deleted automatically when performing the refresh
     * flow.
     *
     * @param flushInactiveOAuth2TokensRequest (optional)
     * @param _callback                        The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Empty responses are sent when, for example, resources are deleted. The HTTP status code
     * for empty responses is typically 201. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call flushInactiveOAuth2TokensAsync(final FlushInactiveOAuth2TokensRequest flushInactiveOAuth2TokensRequest, final ApiCallback<Void> _callback) throws ApiException {

        final okhttp3.Call localVarCall = this.flushInactiveOAuth2TokensValidateBeforeCall(flushInactiveOAuth2TokensRequest, _callback);
        this.localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    /**
     * Build call for getConsentRequest
     *
     * @param consentChallenge (required)
     * @param _callback        Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> consentRequest </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 410 </td><td> requestWasHandledResponse </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call getConsentRequestCall(final String consentChallenge, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        final String[] localBasePaths = new String[]{};

        // Determine Base Path to Use
        if (this.localCustomBaseUrl != null) {
            basePath = this.localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[this.localHostIndex];
        } else {
            basePath = null;
        }

        final Object localVarPostBody = null;

        // create path and map variables
        final String localVarPath = "/oauth2/auth/requests/consent";

        final List<Pair> localVarQueryParams = new ArrayList<>();
        final List<Pair> localVarCollectionQueryParams = new ArrayList<>();
        final Map<String, String> localVarHeaderParams = new HashMap<>();
        final Map<String, String> localVarCookieParams = new HashMap<>();
        final Map<String, Object> localVarFormParams = new HashMap<>();

        if (consentChallenge != null) {
            localVarQueryParams.addAll(this.localVarApiClient.parameterToPair("consent_challenge", consentChallenge));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = this.localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = this.localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        final String[] localVarAuthNames = new String[]{};
        return this.localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getConsentRequestValidateBeforeCall(final String consentChallenge, final ApiCallback _callback) throws ApiException {

        // verify the required parameter 'consentChallenge' is set
        if (consentChallenge == null) {
            throw new ApiException("Missing the required parameter 'consentChallenge' when calling getConsentRequest(Async)");
        }


        final okhttp3.Call localVarCall = this.getConsentRequestCall(consentChallenge, _callback);
        return localVarCall;

    }

    /**
     * Get Consent Request Information When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY
     * Hydra asks the login provider to authenticate the subject and then tell ORY Hydra now about it. If the subject
     * authenticated, he/she must now be asked if the OAuth 2.0 Client which initiated the flow should be allowed to
     * access the resources on the subject&#39;s behalf.  The consent provider which handles this request and is a web
     * app implemented and hosted by you. It shows a subject interface which asks the subject to grant or deny the
     * client access to the requested scope (\&quot;Application my-dropbox-app wants write access to all your private
     * files\&quot;).  The consent challenge is appended to the consent provider&#39;s URL to which the subject&#39;s
     * user-agent (browser) is redirected to. The consent provider uses that challenge to fetch information on the
     * OAuth2 request and then tells ORY Hydra if the subject accepted or rejected the request.
     *
     * @param consentChallenge (required)
     * @return ConsentRequest
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> consentRequest </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 410 </td><td> requestWasHandledResponse </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public ConsentRequest getConsentRequest(final String consentChallenge) throws ApiException {
        final ApiResponse<ConsentRequest> localVarResp = this.getConsentRequestWithHttpInfo(consentChallenge);
        return localVarResp.getData();
    }

    /**
     * Get Consent Request Information When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY
     * Hydra asks the login provider to authenticate the subject and then tell ORY Hydra now about it. If the subject
     * authenticated, he/she must now be asked if the OAuth 2.0 Client which initiated the flow should be allowed to
     * access the resources on the subject&#39;s behalf.  The consent provider which handles this request and is a web
     * app implemented and hosted by you. It shows a subject interface which asks the subject to grant or deny the
     * client access to the requested scope (\&quot;Application my-dropbox-app wants write access to all your private
     * files\&quot;).  The consent challenge is appended to the consent provider&#39;s URL to which the subject&#39;s
     * user-agent (browser) is redirected to. The consent provider uses that challenge to fetch information on the
     * OAuth2 request and then tells ORY Hydra if the subject accepted or rejected the request.
     *
     * @param consentChallenge (required)
     * @return ApiResponse&lt;ConsentRequest&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> consentRequest </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 410 </td><td> requestWasHandledResponse </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<ConsentRequest> getConsentRequestWithHttpInfo(final String consentChallenge) throws ApiException {
        final okhttp3.Call localVarCall = this.getConsentRequestValidateBeforeCall(consentChallenge, null);
        final Type localVarReturnType = new TypeToken<ConsentRequest>() {
        }.getType();
        return this.localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Consent Request Information (asynchronously) When an authorization code, hybrid, or implicit OAuth 2.0 Flow
     * is initiated, ORY Hydra asks the login provider to authenticate the subject and then tell ORY Hydra now about it.
     * If the subject authenticated, he/she must now be asked if the OAuth 2.0 Client which initiated the flow should be
     * allowed to access the resources on the subject&#39;s behalf.  The consent provider which handles this request and
     * is a web app implemented and hosted by you. It shows a subject interface which asks the subject to grant or deny
     * the client access to the requested scope (\&quot;Application my-dropbox-app wants write access to all your
     * private files\&quot;).  The consent challenge is appended to the consent provider&#39;s URL to which the
     * subject&#39;s user-agent (browser) is redirected to. The consent provider uses that challenge to fetch
     * information on the OAuth2 request and then tells ORY Hydra if the subject accepted or rejected the request.
     *
     * @param consentChallenge (required)
     * @param _callback        The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> consentRequest </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 410 </td><td> requestWasHandledResponse </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call getConsentRequestAsync(final String consentChallenge, final ApiCallback<ConsentRequest> _callback) throws ApiException {

        final okhttp3.Call localVarCall = this.getConsentRequestValidateBeforeCall(consentChallenge, _callback);
        final Type localVarReturnType = new TypeToken<ConsentRequest>() {
        }.getType();
        this.localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    /**
     * Build call for getJsonWebKey
     *
     * @param kid       The kid of the desired key (required)
     * @param set       The set (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> JSONWebKeySet </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call getJsonWebKeyCall(final String kid, final String set, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        final String[] localBasePaths = new String[]{};

        // Determine Base Path to Use
        if (this.localCustomBaseUrl != null) {
            basePath = this.localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[this.localHostIndex];
        } else {
            basePath = null;
        }

        final Object localVarPostBody = null;

        // create path and map variables
        final String localVarPath = "/keys/{set}/{kid}"
            .replaceAll("\\{" + "kid" + "\\}", this.localVarApiClient.escapeString(kid))
            .replaceAll("\\{" + "set" + "\\}", this.localVarApiClient.escapeString(set));

        final List<Pair> localVarQueryParams = new ArrayList<>();
        final List<Pair> localVarCollectionQueryParams = new ArrayList<>();
        final Map<String, String> localVarHeaderParams = new HashMap<>();
        final Map<String, String> localVarCookieParams = new HashMap<>();
        final Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = this.localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = this.localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        final String[] localVarAuthNames = new String[]{};
        return this.localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getJsonWebKeyValidateBeforeCall(final String kid, final String set, final ApiCallback _callback) throws ApiException {

        // verify the required parameter 'kid' is set
        if (kid == null) {
            throw new ApiException("Missing the required parameter 'kid' when calling getJsonWebKey(Async)");
        }

        // verify the required parameter 'set' is set
        if (set == null) {
            throw new ApiException("Missing the required parameter 'set' when calling getJsonWebKey(Async)");
        }


        final okhttp3.Call localVarCall = this.getJsonWebKeyCall(kid, set, _callback);
        return localVarCall;

    }

    /**
     * Fetch a JSON Web Key This endpoint returns a singular JSON Web Key, identified by the set and the specific key ID
     * (kid).
     *
     * @param kid The kid of the desired key (required)
     * @param set The set (required)
     * @return JSONWebKeySet
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> JSONWebKeySet </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public JSONWebKeySet getJsonWebKey(final String kid, final String set) throws ApiException {
        final ApiResponse<JSONWebKeySet> localVarResp = this.getJsonWebKeyWithHttpInfo(kid, set);
        return localVarResp.getData();
    }

    /**
     * Fetch a JSON Web Key This endpoint returns a singular JSON Web Key, identified by the set and the specific key ID
     * (kid).
     *
     * @param kid The kid of the desired key (required)
     * @param set The set (required)
     * @return ApiResponse&lt;JSONWebKeySet&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> JSONWebKeySet </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<JSONWebKeySet> getJsonWebKeyWithHttpInfo(final String kid, final String set) throws ApiException {
        final okhttp3.Call localVarCall = this.getJsonWebKeyValidateBeforeCall(kid, set, null);
        final Type localVarReturnType = new TypeToken<JSONWebKeySet>() {
        }.getType();
        return this.localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Fetch a JSON Web Key (asynchronously) This endpoint returns a singular JSON Web Key, identified by the set and
     * the specific key ID (kid).
     *
     * @param kid       The kid of the desired key (required)
     * @param set       The set (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> JSONWebKeySet </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call getJsonWebKeyAsync(final String kid, final String set, final ApiCallback<JSONWebKeySet> _callback) throws ApiException {

        final okhttp3.Call localVarCall = this.getJsonWebKeyValidateBeforeCall(kid, set, _callback);
        final Type localVarReturnType = new TypeToken<JSONWebKeySet>() {
        }.getType();
        this.localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    /**
     * Build call for getJsonWebKeySet
     *
     * @param set       The set (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> JSONWebKeySet </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call getJsonWebKeySetCall(final String set, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        final String[] localBasePaths = new String[]{};

        // Determine Base Path to Use
        if (this.localCustomBaseUrl != null) {
            basePath = this.localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[this.localHostIndex];
        } else {
            basePath = null;
        }

        final Object localVarPostBody = null;

        // create path and map variables
        final String localVarPath = "/keys/{set}"
            .replaceAll("\\{" + "set" + "\\}", this.localVarApiClient.escapeString(set));

        final List<Pair> localVarQueryParams = new ArrayList<>();
        final List<Pair> localVarCollectionQueryParams = new ArrayList<>();
        final Map<String, String> localVarHeaderParams = new HashMap<>();
        final Map<String, String> localVarCookieParams = new HashMap<>();
        final Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = this.localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = this.localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        final String[] localVarAuthNames = new String[]{};
        return this.localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getJsonWebKeySetValidateBeforeCall(final String set, final ApiCallback _callback) throws ApiException {

        // verify the required parameter 'set' is set
        if (set == null) {
            throw new ApiException("Missing the required parameter 'set' when calling getJsonWebKeySet(Async)");
        }


        final okhttp3.Call localVarCall = this.getJsonWebKeySetCall(set, _callback);
        return localVarCall;

    }

    /**
     * Retrieve a JSON Web Key Set This endpoint can be used to retrieve JWK Sets stored in ORY Hydra.  A JSON Web Key
     * (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a
     * JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra
     * uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID
     * tokens), and allows storing user-defined keys as well.
     *
     * @param set The set (required)
     * @return JSONWebKeySet
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> JSONWebKeySet </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public JSONWebKeySet getJsonWebKeySet(final String set) throws ApiException {
        final ApiResponse<JSONWebKeySet> localVarResp = this.getJsonWebKeySetWithHttpInfo(set);
        return localVarResp.getData();
    }

    /**
     * Retrieve a JSON Web Key Set This endpoint can be used to retrieve JWK Sets stored in ORY Hydra.  A JSON Web Key
     * (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A JWK Set is a
     * JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key id. ORY Hydra
     * uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as OpenID Connect ID
     * tokens), and allows storing user-defined keys as well.
     *
     * @param set The set (required)
     * @return ApiResponse&lt;JSONWebKeySet&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> JSONWebKeySet </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<JSONWebKeySet> getJsonWebKeySetWithHttpInfo(final String set) throws ApiException {
        final okhttp3.Call localVarCall = this.getJsonWebKeySetValidateBeforeCall(set, null);
        final Type localVarReturnType = new TypeToken<JSONWebKeySet>() {
        }.getType();
        return this.localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Retrieve a JSON Web Key Set (asynchronously) This endpoint can be used to retrieve JWK Sets stored in ORY Hydra.
     * A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a cryptographic key. A
     * JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified by its set and key
     * id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web Tokens (such as
     * OpenID Connect ID tokens), and allows storing user-defined keys as well.
     *
     * @param set       The set (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> JSONWebKeySet </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call getJsonWebKeySetAsync(final String set, final ApiCallback<JSONWebKeySet> _callback) throws ApiException {

        final okhttp3.Call localVarCall = this.getJsonWebKeySetValidateBeforeCall(set, _callback);
        final Type localVarReturnType = new TypeToken<JSONWebKeySet>() {
        }.getType();
        this.localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    /**
     * Build call for getLoginRequest
     *
     * @param loginChallenge (required)
     * @param _callback      Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> loginRequest </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 410 </td><td> requestWasHandledResponse </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call getLoginRequestCall(final String loginChallenge, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        final String[] localBasePaths = new String[]{};

        // Determine Base Path to Use
        if (this.localCustomBaseUrl != null) {
            basePath = this.localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[this.localHostIndex];
        } else {
            basePath = null;
        }

        final Object localVarPostBody = null;

        // create path and map variables
        final String localVarPath = "/oauth2/auth/requests/login";

        final List<Pair> localVarQueryParams = new ArrayList<>();
        final List<Pair> localVarCollectionQueryParams = new ArrayList<>();
        final Map<String, String> localVarHeaderParams = new HashMap<>();
        final Map<String, String> localVarCookieParams = new HashMap<>();
        final Map<String, Object> localVarFormParams = new HashMap<>();

        if (loginChallenge != null) {
            localVarQueryParams.addAll(this.localVarApiClient.parameterToPair("login_challenge", loginChallenge));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = this.localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = this.localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        final String[] localVarAuthNames = new String[]{};
        return this.localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getLoginRequestValidateBeforeCall(final String loginChallenge, final ApiCallback _callback) throws ApiException {

        // verify the required parameter 'loginChallenge' is set
        if (loginChallenge == null) {
            throw new ApiException("Missing the required parameter 'loginChallenge' when calling getLoginRequest(Async)");
        }


        final okhttp3.Call localVarCall = this.getLoginRequestCall(loginChallenge, _callback);
        return localVarCall;

    }

    /**
     * Get a Login Request When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks
     * the login provider (sometimes called \&quot;identity provider\&quot;) to authenticate the subject and then tell
     * ORY Hydra now about it. The login provider is an web-app you write and host, and it must be able to authenticate
     * (\&quot;show the subject a login screen\&quot;) a subject (in OAuth2 the proper name for subject is
     * \&quot;resource owner\&quot;).  The authentication challenge is appended to the login provider URL to which the
     * subject&#39;s user-agent (browser) is redirected to. The login provider uses that challenge to fetch information
     * on the OAuth2 request and then accept or reject the requested authentication process.
     *
     * @param loginChallenge (required)
     * @return LoginRequest
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> loginRequest </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 410 </td><td> requestWasHandledResponse </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public LoginRequest getLoginRequest(final String loginChallenge) throws ApiException {
        final ApiResponse<LoginRequest> localVarResp = this.getLoginRequestWithHttpInfo(loginChallenge);
        return localVarResp.getData();
    }

    /**
     * Get a Login Request When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra asks
     * the login provider (sometimes called \&quot;identity provider\&quot;) to authenticate the subject and then tell
     * ORY Hydra now about it. The login provider is an web-app you write and host, and it must be able to authenticate
     * (\&quot;show the subject a login screen\&quot;) a subject (in OAuth2 the proper name for subject is
     * \&quot;resource owner\&quot;).  The authentication challenge is appended to the login provider URL to which the
     * subject&#39;s user-agent (browser) is redirected to. The login provider uses that challenge to fetch information
     * on the OAuth2 request and then accept or reject the requested authentication process.
     *
     * @param loginChallenge (required)
     * @return ApiResponse&lt;LoginRequest&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> loginRequest </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 410 </td><td> requestWasHandledResponse </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<LoginRequest> getLoginRequestWithHttpInfo(final String loginChallenge) throws ApiException {
        final okhttp3.Call localVarCall = this.getLoginRequestValidateBeforeCall(loginChallenge, null);
        final Type localVarReturnType = new TypeToken<LoginRequest>() {
        }.getType();
        return this.localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get a Login Request (asynchronously) When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated,
     * ORY Hydra asks the login provider (sometimes called \&quot;identity provider\&quot;) to authenticate the subject
     * and then tell ORY Hydra now about it. The login provider is an web-app you write and host, and it must be able to
     * authenticate (\&quot;show the subject a login screen\&quot;) a subject (in OAuth2 the proper name for subject is
     * \&quot;resource owner\&quot;).  The authentication challenge is appended to the login provider URL to which the
     * subject&#39;s user-agent (browser) is redirected to. The login provider uses that challenge to fetch information
     * on the OAuth2 request and then accept or reject the requested authentication process.
     *
     * @param loginChallenge (required)
     * @param _callback      The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> loginRequest </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 410 </td><td> requestWasHandledResponse </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call getLoginRequestAsync(final String loginChallenge, final ApiCallback<LoginRequest> _callback) throws ApiException {

        final okhttp3.Call localVarCall = this.getLoginRequestValidateBeforeCall(loginChallenge, _callback);
        final Type localVarReturnType = new TypeToken<LoginRequest>() {
        }.getType();
        this.localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    /**
     * Build call for getLogoutRequest
     *
     * @param logoutChallenge (required)
     * @param _callback       Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> logoutRequest </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 410 </td><td> requestWasHandledResponse </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call getLogoutRequestCall(final String logoutChallenge, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        final String[] localBasePaths = new String[]{};

        // Determine Base Path to Use
        if (this.localCustomBaseUrl != null) {
            basePath = this.localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[this.localHostIndex];
        } else {
            basePath = null;
        }

        final Object localVarPostBody = null;

        // create path and map variables
        final String localVarPath = "/oauth2/auth/requests/logout";

        final List<Pair> localVarQueryParams = new ArrayList<>();
        final List<Pair> localVarCollectionQueryParams = new ArrayList<>();
        final Map<String, String> localVarHeaderParams = new HashMap<>();
        final Map<String, String> localVarCookieParams = new HashMap<>();
        final Map<String, Object> localVarFormParams = new HashMap<>();

        if (logoutChallenge != null) {
            localVarQueryParams.addAll(this.localVarApiClient.parameterToPair("logout_challenge", logoutChallenge));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = this.localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = this.localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        final String[] localVarAuthNames = new String[]{};
        return this.localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getLogoutRequestValidateBeforeCall(final String logoutChallenge, final ApiCallback _callback) throws ApiException {

        // verify the required parameter 'logoutChallenge' is set
        if (logoutChallenge == null) {
            throw new ApiException("Missing the required parameter 'logoutChallenge' when calling getLogoutRequest(Async)");
        }


        final okhttp3.Call localVarCall = this.getLogoutRequestCall(logoutChallenge, _callback);
        return localVarCall;

    }

    /**
     * Get a Logout Request Use this endpoint to fetch a logout request.
     *
     * @param logoutChallenge (required)
     * @return LogoutRequest
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> logoutRequest </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 410 </td><td> requestWasHandledResponse </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public LogoutRequest getLogoutRequest(final String logoutChallenge) throws ApiException {
        final ApiResponse<LogoutRequest> localVarResp = this.getLogoutRequestWithHttpInfo(logoutChallenge);
        return localVarResp.getData();
    }

    /**
     * Get a Logout Request Use this endpoint to fetch a logout request.
     *
     * @param logoutChallenge (required)
     * @return ApiResponse&lt;LogoutRequest&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> logoutRequest </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 410 </td><td> requestWasHandledResponse </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<LogoutRequest> getLogoutRequestWithHttpInfo(final String logoutChallenge) throws ApiException {
        final okhttp3.Call localVarCall = this.getLogoutRequestValidateBeforeCall(logoutChallenge, null);
        final Type localVarReturnType = new TypeToken<LogoutRequest>() {
        }.getType();
        return this.localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get a Logout Request (asynchronously) Use this endpoint to fetch a logout request.
     *
     * @param logoutChallenge (required)
     * @param _callback       The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> logoutRequest </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 410 </td><td> requestWasHandledResponse </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call getLogoutRequestAsync(final String logoutChallenge, final ApiCallback<LogoutRequest> _callback) throws ApiException {

        final okhttp3.Call localVarCall = this.getLogoutRequestValidateBeforeCall(logoutChallenge, _callback);
        final Type localVarReturnType = new TypeToken<LogoutRequest>() {
        }.getType();
        this.localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    /**
     * Build call for getOAuth2Client
     *
     * @param id        The id of the OAuth 2.0 Client. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> oAuth2Client </td><td>  -  </td></tr>
     * <tr><td> 0 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call getOAuth2ClientCall(final String id, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        final String[] localBasePaths = new String[]{};

        // Determine Base Path to Use
        if (this.localCustomBaseUrl != null) {
            basePath = this.localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[this.localHostIndex];
        } else {
            basePath = null;
        }

        final Object localVarPostBody = null;

        // create path and map variables
        final String localVarPath = "/clients/{id}"
            .replaceAll("\\{" + "id" + "\\}", this.localVarApiClient.escapeString(id));

        final List<Pair> localVarQueryParams = new ArrayList<>();
        final List<Pair> localVarCollectionQueryParams = new ArrayList<>();
        final Map<String, String> localVarHeaderParams = new HashMap<>();
        final Map<String, String> localVarCookieParams = new HashMap<>();
        final Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = this.localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = this.localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        final String[] localVarAuthNames = new String[]{};
        return this.localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getOAuth2ClientValidateBeforeCall(final String id, final ApiCallback _callback) throws ApiException {

        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling getOAuth2Client(Async)");
        }


        final okhttp3.Call localVarCall = this.getOAuth2ClientCall(id, _callback);
        return localVarCall;

    }

    /**
     * Get an OAuth 2.0 Client Get an OAuth 2.0 client by its ID. This endpoint never returns the client secret.  OAuth
     * 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for
     * applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
     *
     * @param id The id of the OAuth 2.0 Client. (required)
     * @return OAuth2Client
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> oAuth2Client </td><td>  -  </td></tr>
     * <tr><td> 0 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public OAuth2Client getOAuth2Client(final String id) throws ApiException {
        final ApiResponse<OAuth2Client> localVarResp = this.getOAuth2ClientWithHttpInfo(id);
        return localVarResp.getData();
    }

    /**
     * Get an OAuth 2.0 Client Get an OAuth 2.0 client by its ID. This endpoint never returns the client secret.  OAuth
     * 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for
     * applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
     *
     * @param id The id of the OAuth 2.0 Client. (required)
     * @return ApiResponse&lt;OAuth2Client&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> oAuth2Client </td><td>  -  </td></tr>
     * <tr><td> 0 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<OAuth2Client> getOAuth2ClientWithHttpInfo(final String id) throws ApiException {
        final okhttp3.Call localVarCall = this.getOAuth2ClientValidateBeforeCall(id, null);
        final Type localVarReturnType = new TypeToken<OAuth2Client>() {
        }.getType();
        return this.localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get an OAuth 2.0 Client (asynchronously) Get an OAuth 2.0 client by its ID. This endpoint never returns the
     * client secret.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0
     * clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.
     *
     * @param id        The id of the OAuth 2.0 Client. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> oAuth2Client </td><td>  -  </td></tr>
     * <tr><td> 0 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call getOAuth2ClientAsync(final String id, final ApiCallback<OAuth2Client> _callback) throws ApiException {

        final okhttp3.Call localVarCall = this.getOAuth2ClientValidateBeforeCall(id, _callback);
        final Type localVarReturnType = new TypeToken<OAuth2Client>() {
        }.getType();
        this.localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    /**
     * Build call for getTrustedJwtGrantIssuer
     *
     * @param id        The id of the desired grant (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> trustedJwtGrantIssuer </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> genericError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> genericError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call getTrustedJwtGrantIssuerCall(final String id, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        final String[] localBasePaths = new String[]{};

        // Determine Base Path to Use
        if (this.localCustomBaseUrl != null) {
            basePath = this.localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[this.localHostIndex];
        } else {
            basePath = null;
        }

        final Object localVarPostBody = null;

        // create path and map variables
        final String localVarPath = "/trust/grants/jwt-bearer/issuers/{id}"
            .replaceAll("\\{" + "id" + "\\}", this.localVarApiClient.escapeString(id));

        final List<Pair> localVarQueryParams = new ArrayList<>();
        final List<Pair> localVarCollectionQueryParams = new ArrayList<>();
        final Map<String, String> localVarHeaderParams = new HashMap<>();
        final Map<String, String> localVarCookieParams = new HashMap<>();
        final Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = this.localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = this.localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        final String[] localVarAuthNames = new String[]{};
        return this.localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getTrustedJwtGrantIssuerValidateBeforeCall(final String id, final ApiCallback _callback) throws ApiException {

        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling getTrustedJwtGrantIssuer(Async)");
        }


        final okhttp3.Call localVarCall = this.getTrustedJwtGrantIssuerCall(id, _callback);
        return localVarCall;

    }

    /**
     * Get a Trusted OAuth2 JWT Bearer Grant Type Issuer Use this endpoint to get a trusted JWT Bearer Grant Type
     * Issuer. The ID is the one returned when you created the trust relationship.
     *
     * @param id The id of the desired grant (required)
     * @return TrustedJwtGrantIssuer
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> trustedJwtGrantIssuer </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> genericError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> genericError </td><td>  -  </td></tr>
     * </table>
     */
    public TrustedJwtGrantIssuer getTrustedJwtGrantIssuer(final String id) throws ApiException {
        final ApiResponse<TrustedJwtGrantIssuer> localVarResp = this.getTrustedJwtGrantIssuerWithHttpInfo(id);
        return localVarResp.getData();
    }

    /**
     * Get a Trusted OAuth2 JWT Bearer Grant Type Issuer Use this endpoint to get a trusted JWT Bearer Grant Type
     * Issuer. The ID is the one returned when you created the trust relationship.
     *
     * @param id The id of the desired grant (required)
     * @return ApiResponse&lt;TrustedJwtGrantIssuer&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> trustedJwtGrantIssuer </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> genericError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> genericError </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<TrustedJwtGrantIssuer> getTrustedJwtGrantIssuerWithHttpInfo(final String id) throws ApiException {
        final okhttp3.Call localVarCall = this.getTrustedJwtGrantIssuerValidateBeforeCall(id, null);
        final Type localVarReturnType = new TypeToken<TrustedJwtGrantIssuer>() {
        }.getType();
        return this.localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get a Trusted OAuth2 JWT Bearer Grant Type Issuer (asynchronously) Use this endpoint to get a trusted JWT Bearer
     * Grant Type Issuer. The ID is the one returned when you created the trust relationship.
     *
     * @param id        The id of the desired grant (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> trustedJwtGrantIssuer </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> genericError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> genericError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call getTrustedJwtGrantIssuerAsync(final String id, final ApiCallback<TrustedJwtGrantIssuer> _callback) throws ApiException {

        final okhttp3.Call localVarCall = this.getTrustedJwtGrantIssuerValidateBeforeCall(id, _callback);
        final Type localVarReturnType = new TypeToken<TrustedJwtGrantIssuer>() {
        }.getType();
        this.localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    /**
     * Build call for introspectOAuth2Token
     *
     * @param token     The string value of the token. For access tokens, this is the \\\&quot;access_token\\\&quot;
     *                  value returned from the token endpoint defined in OAuth 2.0. For refresh tokens, this is the
     *                  \\\&quot;refresh_token\\\&quot; value returned. (required)
     * @param scope     An optional, space separated list of required scopes. If the access token was not granted one of
     *                  the scopes, the result of active will be false. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> oAuth2TokenIntrospection </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call introspectOAuth2TokenCall(final String token, final String scope, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        final String[] localBasePaths = new String[]{};

        // Determine Base Path to Use
        if (this.localCustomBaseUrl != null) {
            basePath = this.localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[this.localHostIndex];
        } else {
            basePath = null;
        }

        final Object localVarPostBody = null;

        // create path and map variables
        final String localVarPath = "/oauth2/introspect";

        final List<Pair> localVarQueryParams = new ArrayList<>();
        final List<Pair> localVarCollectionQueryParams = new ArrayList<>();
        final Map<String, String> localVarHeaderParams = new HashMap<>();
        final Map<String, String> localVarCookieParams = new HashMap<>();
        final Map<String, Object> localVarFormParams = new HashMap<>();

        if (scope != null) {
            localVarFormParams.put("scope", scope);
        }

        if (token != null) {
            localVarFormParams.put("token", token);
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = this.localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = this.localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        final String[] localVarAuthNames = new String[]{};
        return this.localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call introspectOAuth2TokenValidateBeforeCall(final String token, final String scope, final ApiCallback _callback) throws ApiException {

        // verify the required parameter 'token' is set
        if (token == null) {
            throw new ApiException("Missing the required parameter 'token' when calling introspectOAuth2Token(Async)");
        }


        final okhttp3.Call localVarCall = this.introspectOAuth2TokenCall(token, scope, _callback);
        return localVarCall;

    }

    /**
     * Introspect OAuth2 Tokens The introspection endpoint allows to check if a token (both refresh and access) is
     * active or not. An active token is neither expired nor revoked. If a token is active, additional information on
     * the token will be included. You can set additional data for a token by setting &#x60;accessTokenExtra&#x60;
     * during the consent flow.  For more information [read this blog
     * post](https://www.oauth.com/oauth2-servers/token-introspection-endpoint/).
     *
     * @param token The string value of the token. For access tokens, this is the \\\&quot;access_token\\\&quot; value
     *              returned from the token endpoint defined in OAuth 2.0. For refresh tokens, this is the
     *              \\\&quot;refresh_token\\\&quot; value returned. (required)
     * @param scope An optional, space separated list of required scopes. If the access token was not granted one of the
     *              scopes, the result of active will be false. (optional)
     * @return OAuth2TokenIntrospection
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> oAuth2TokenIntrospection </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public OAuth2TokenIntrospection introspectOAuth2Token(final String token, final String scope) throws ApiException {
        final ApiResponse<OAuth2TokenIntrospection> localVarResp = this.introspectOAuth2TokenWithHttpInfo(token, scope);
        return localVarResp.getData();
    }

    /**
     * Introspect OAuth2 Tokens The introspection endpoint allows to check if a token (both refresh and access) is
     * active or not. An active token is neither expired nor revoked. If a token is active, additional information on
     * the token will be included. You can set additional data for a token by setting &#x60;accessTokenExtra&#x60;
     * during the consent flow.  For more information [read this blog
     * post](https://www.oauth.com/oauth2-servers/token-introspection-endpoint/).
     *
     * @param token The string value of the token. For access tokens, this is the \\\&quot;access_token\\\&quot; value
     *              returned from the token endpoint defined in OAuth 2.0. For refresh tokens, this is the
     *              \\\&quot;refresh_token\\\&quot; value returned. (required)
     * @param scope An optional, space separated list of required scopes. If the access token was not granted one of the
     *              scopes, the result of active will be false. (optional)
     * @return ApiResponse&lt;OAuth2TokenIntrospection&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> oAuth2TokenIntrospection </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<OAuth2TokenIntrospection> introspectOAuth2TokenWithHttpInfo(final String token, final String scope) throws ApiException {
        final okhttp3.Call localVarCall = this.introspectOAuth2TokenValidateBeforeCall(token, scope, null);
        final Type localVarReturnType = new TypeToken<OAuth2TokenIntrospection>() {
        }.getType();
        return this.localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Introspect OAuth2 Tokens (asynchronously) The introspection endpoint allows to check if a token (both refresh and
     * access) is active or not. An active token is neither expired nor revoked. If a token is active, additional
     * information on the token will be included. You can set additional data for a token by setting
     * &#x60;accessTokenExtra&#x60; during the consent flow.  For more information [read this blog
     * post](https://www.oauth.com/oauth2-servers/token-introspection-endpoint/).
     *
     * @param token     The string value of the token. For access tokens, this is the \\\&quot;access_token\\\&quot;
     *                  value returned from the token endpoint defined in OAuth 2.0. For refresh tokens, this is the
     *                  \\\&quot;refresh_token\\\&quot; value returned. (required)
     * @param scope     An optional, space separated list of required scopes. If the access token was not granted one of
     *                  the scopes, the result of active will be false. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> oAuth2TokenIntrospection </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call introspectOAuth2TokenAsync(final String token, final String scope, final ApiCallback<OAuth2TokenIntrospection> _callback) throws ApiException {

        final okhttp3.Call localVarCall = this.introspectOAuth2TokenValidateBeforeCall(token, scope, _callback);
        final Type localVarReturnType = new TypeToken<OAuth2TokenIntrospection>() {
        }.getType();
        this.localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    /**
     * Build call for listOAuth2Clients
     *
     * @param limit      The maximum amount of clients to returned, upper bound is 500 clients. (optional)
     * @param offset     The offset from where to start looking. (optional)
     * @param clientName The name of the clients to filter by. (optional)
     * @param owner      The owner of the clients to filter by. (optional)
     * @param _callback  Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> A list of clients. </td><td>  -  </td></tr>
     * <tr><td> 0 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call listOAuth2ClientsCall(final Long limit, final Long offset, final String clientName, final String owner, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        final String[] localBasePaths = new String[]{};

        // Determine Base Path to Use
        if (this.localCustomBaseUrl != null) {
            basePath = this.localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[this.localHostIndex];
        } else {
            basePath = null;
        }

        final Object localVarPostBody = null;

        // create path and map variables
        final String localVarPath = "/clients";

        final List<Pair> localVarQueryParams = new ArrayList<>();
        final List<Pair> localVarCollectionQueryParams = new ArrayList<>();
        final Map<String, String> localVarHeaderParams = new HashMap<>();
        final Map<String, String> localVarCookieParams = new HashMap<>();
        final Map<String, Object> localVarFormParams = new HashMap<>();

        if (limit != null) {
            localVarQueryParams.addAll(this.localVarApiClient.parameterToPair("limit", limit));
        }

        if (offset != null) {
            localVarQueryParams.addAll(this.localVarApiClient.parameterToPair("offset", offset));
        }

        if (clientName != null) {
            localVarQueryParams.addAll(this.localVarApiClient.parameterToPair("client_name", clientName));
        }

        if (owner != null) {
            localVarQueryParams.addAll(this.localVarApiClient.parameterToPair("owner", owner));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = this.localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = this.localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        final String[] localVarAuthNames = new String[]{};
        return this.localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listOAuth2ClientsValidateBeforeCall(final Long limit, final Long offset, final String clientName, final String owner, final ApiCallback _callback) throws ApiException {


        final okhttp3.Call localVarCall = this.listOAuth2ClientsCall(limit, offset, clientName, owner, _callback);
        return localVarCall;

    }

    /**
     * List OAuth 2.0 Clients This endpoint lists all clients in the database, and never returns client secrets. As a
     * default it lists the first 100 clients. The &#x60;limit&#x60; parameter can be used to retrieve more clients, but
     * it has an upper bound at 500 objects. Pagination should be used to retrieve more than 500 objects.  OAuth 2.0
     * clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for
     * applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.  The \&quot;Link\&quot; header
     * is also included in successful responses, which contains one or more links for pagination, formatted like so:
     * &#39;&lt;https://hydra-url/admin/clients?limit&#x3D;{limit}&amp;offset&#x3D;{offset}&gt;;
     * rel&#x3D;\&quot;{page}\&quot;&#39;, where page is one of the following applicable pages: &#39;first&#39;,
     * &#39;next&#39;, &#39;last&#39;, and &#39;previous&#39;. Multiple links can be included in this header, and will
     * be separated by a comma.
     *
     * @param limit      The maximum amount of clients to returned, upper bound is 500 clients. (optional)
     * @param offset     The offset from where to start looking. (optional)
     * @param clientName The name of the clients to filter by. (optional)
     * @param owner      The owner of the clients to filter by. (optional)
     * @return List&lt;OAuth2Client&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> A list of clients. </td><td>  -  </td></tr>
     * <tr><td> 0 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public List<OAuth2Client> listOAuth2Clients(final Long limit, final Long offset, final String clientName, final String owner) throws ApiException {
        final ApiResponse<List<OAuth2Client>> localVarResp = this.listOAuth2ClientsWithHttpInfo(limit, offset, clientName, owner);
        return localVarResp.getData();
    }

    /**
     * List OAuth 2.0 Clients This endpoint lists all clients in the database, and never returns client secrets. As a
     * default it lists the first 100 clients. The &#x60;limit&#x60; parameter can be used to retrieve more clients, but
     * it has an upper bound at 500 objects. Pagination should be used to retrieve more than 500 objects.  OAuth 2.0
     * clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for
     * applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.  The \&quot;Link\&quot; header
     * is also included in successful responses, which contains one or more links for pagination, formatted like so:
     * &#39;&lt;https://hydra-url/admin/clients?limit&#x3D;{limit}&amp;offset&#x3D;{offset}&gt;;
     * rel&#x3D;\&quot;{page}\&quot;&#39;, where page is one of the following applicable pages: &#39;first&#39;,
     * &#39;next&#39;, &#39;last&#39;, and &#39;previous&#39;. Multiple links can be included in this header, and will
     * be separated by a comma.
     *
     * @param limit      The maximum amount of clients to returned, upper bound is 500 clients. (optional)
     * @param offset     The offset from where to start looking. (optional)
     * @param clientName The name of the clients to filter by. (optional)
     * @param owner      The owner of the clients to filter by. (optional)
     * @return ApiResponse&lt;List&lt;OAuth2Client&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> A list of clients. </td><td>  -  </td></tr>
     * <tr><td> 0 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<List<OAuth2Client>> listOAuth2ClientsWithHttpInfo(final Long limit, final Long offset, final String clientName, final String owner) throws ApiException {
        final okhttp3.Call localVarCall = this.listOAuth2ClientsValidateBeforeCall(limit, offset, clientName, owner, null);
        final Type localVarReturnType = new TypeToken<List<OAuth2Client>>() {
        }.getType();
        return this.localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List OAuth 2.0 Clients (asynchronously) This endpoint lists all clients in the database, and never returns client
     * secrets. As a default it lists the first 100 clients. The &#x60;limit&#x60; parameter can be used to retrieve
     * more clients, but it has an upper bound at 500 objects. Pagination should be used to retrieve more than 500
     * objects.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients
     * are generated for applications which want to consume your OAuth 2.0 or OpenID Connect capabilities.  The
     * \&quot;Link\&quot; header is also included in successful responses, which contains one or more links for
     * pagination, formatted like so:
     * &#39;&lt;https://hydra-url/admin/clients?limit&#x3D;{limit}&amp;offset&#x3D;{offset}&gt;;
     * rel&#x3D;\&quot;{page}\&quot;&#39;, where page is one of the following applicable pages: &#39;first&#39;,
     * &#39;next&#39;, &#39;last&#39;, and &#39;previous&#39;. Multiple links can be included in this header, and will
     * be separated by a comma.
     *
     * @param limit      The maximum amount of clients to returned, upper bound is 500 clients. (optional)
     * @param offset     The offset from where to start looking. (optional)
     * @param clientName The name of the clients to filter by. (optional)
     * @param owner      The owner of the clients to filter by. (optional)
     * @param _callback  The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> A list of clients. </td><td>  -  </td></tr>
     * <tr><td> 0 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call listOAuth2ClientsAsync(final Long limit, final Long offset, final String clientName, final String owner, final ApiCallback<List<OAuth2Client>> _callback) throws ApiException {

        final okhttp3.Call localVarCall = this.listOAuth2ClientsValidateBeforeCall(limit, offset, clientName, owner, _callback);
        final Type localVarReturnType = new TypeToken<List<OAuth2Client>>() {
        }.getType();
        this.localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    /**
     * Build call for listSubjectConsentSessions
     *
     * @param subject   (required)
     * @param limit     The maximum amount of consent sessions to be returned, upper bound is 500 sessions. (optional)
     * @param offset    The offset from where to start looking. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> A list of used consent requests. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call listSubjectConsentSessionsCall(final String subject, final Long limit, final Long offset, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        final String[] localBasePaths = new String[]{};

        // Determine Base Path to Use
        if (this.localCustomBaseUrl != null) {
            basePath = this.localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[this.localHostIndex];
        } else {
            basePath = null;
        }

        final Object localVarPostBody = null;

        // create path and map variables
        final String localVarPath = "/oauth2/auth/sessions/consent";

        final List<Pair> localVarQueryParams = new ArrayList<>();
        final List<Pair> localVarCollectionQueryParams = new ArrayList<>();
        final Map<String, String> localVarHeaderParams = new HashMap<>();
        final Map<String, String> localVarCookieParams = new HashMap<>();
        final Map<String, Object> localVarFormParams = new HashMap<>();

        if (subject != null) {
            localVarQueryParams.addAll(this.localVarApiClient.parameterToPair("subject", subject));
        }

        if (limit != null) {
            localVarQueryParams.addAll(this.localVarApiClient.parameterToPair("limit", limit));
        }

        if (offset != null) {
            localVarQueryParams.addAll(this.localVarApiClient.parameterToPair("offset", offset));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = this.localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = this.localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        final String[] localVarAuthNames = new String[]{};
        return this.localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listSubjectConsentSessionsValidateBeforeCall(final String subject, final Long limit, final Long offset, final ApiCallback _callback) throws ApiException {

        // verify the required parameter 'subject' is set
        if (subject == null) {
            throw new ApiException("Missing the required parameter 'subject' when calling listSubjectConsentSessions(Async)");
        }


        final okhttp3.Call localVarCall = this.listSubjectConsentSessionsCall(subject, limit, offset, _callback);
        return localVarCall;

    }

    /**
     * Lists All Consent Sessions of a Subject This endpoint lists all subject&#39;s granted consent sessions, including
     * client and granted scope. If the subject is unknown or has not granted any consent sessions yet, the endpoint
     * returns an empty JSON array with status code 200 OK.   The \&quot;Link\&quot; header is also included in
     * successful responses, which contains one or more links for pagination, formatted like so:
     * &#39;&lt;https://hydra-url/admin/oauth2/auth/sessions/consent?subject&#x3D;{user}&amp;limit&#x3D;{limit}&amp;offset&#x3D;{offset}&gt;;
     * rel&#x3D;\&quot;{page}\&quot;&#39;, where page is one of the following applicable pages: &#39;first&#39;,
     * &#39;next&#39;, &#39;last&#39;, and &#39;previous&#39;. Multiple links can be included in this header, and will
     * be separated by a comma.
     *
     * @param subject (required)
     * @param limit   The maximum amount of consent sessions to be returned, upper bound is 500 sessions. (optional)
     * @param offset  The offset from where to start looking. (optional)
     * @return List&lt;PreviousConsentSession&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> A list of used consent requests. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public List<PreviousConsentSession> listSubjectConsentSessions(final String subject, final Long limit, final Long offset) throws ApiException {
        final ApiResponse<List<PreviousConsentSession>> localVarResp = this.listSubjectConsentSessionsWithHttpInfo(subject, limit, offset);
        return localVarResp.getData();
    }

    /**
     * Lists All Consent Sessions of a Subject This endpoint lists all subject&#39;s granted consent sessions, including
     * client and granted scope. If the subject is unknown or has not granted any consent sessions yet, the endpoint
     * returns an empty JSON array with status code 200 OK.   The \&quot;Link\&quot; header is also included in
     * successful responses, which contains one or more links for pagination, formatted like so:
     * &#39;&lt;https://hydra-url/admin/oauth2/auth/sessions/consent?subject&#x3D;{user}&amp;limit&#x3D;{limit}&amp;offset&#x3D;{offset}&gt;;
     * rel&#x3D;\&quot;{page}\&quot;&#39;, where page is one of the following applicable pages: &#39;first&#39;,
     * &#39;next&#39;, &#39;last&#39;, and &#39;previous&#39;. Multiple links can be included in this header, and will
     * be separated by a comma.
     *
     * @param subject (required)
     * @param limit   The maximum amount of consent sessions to be returned, upper bound is 500 sessions. (optional)
     * @param offset  The offset from where to start looking. (optional)
     * @return ApiResponse&lt;List&lt;PreviousConsentSession&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> A list of used consent requests. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<List<PreviousConsentSession>> listSubjectConsentSessionsWithHttpInfo(final String subject, final Long limit, final Long offset) throws ApiException {
        final okhttp3.Call localVarCall = this.listSubjectConsentSessionsValidateBeforeCall(subject, limit, offset, null);
        final Type localVarReturnType = new TypeToken<List<PreviousConsentSession>>() {
        }.getType();
        return this.localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Lists All Consent Sessions of a Subject (asynchronously) This endpoint lists all subject&#39;s granted consent
     * sessions, including client and granted scope. If the subject is unknown or has not granted any consent sessions
     * yet, the endpoint returns an empty JSON array with status code 200 OK.   The \&quot;Link\&quot; header is also
     * included in successful responses, which contains one or more links for pagination, formatted like so:
     * &#39;&lt;https://hydra-url/admin/oauth2/auth/sessions/consent?subject&#x3D;{user}&amp;limit&#x3D;{limit}&amp;offset&#x3D;{offset}&gt;;
     * rel&#x3D;\&quot;{page}\&quot;&#39;, where page is one of the following applicable pages: &#39;first&#39;,
     * &#39;next&#39;, &#39;last&#39;, and &#39;previous&#39;. Multiple links can be included in this header, and will
     * be separated by a comma.
     *
     * @param subject   (required)
     * @param limit     The maximum amount of consent sessions to be returned, upper bound is 500 sessions. (optional)
     * @param offset    The offset from where to start looking. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> A list of used consent requests. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call listSubjectConsentSessionsAsync(final String subject, final Long limit, final Long offset, final ApiCallback<List<PreviousConsentSession>> _callback) throws ApiException {

        final okhttp3.Call localVarCall = this.listSubjectConsentSessionsValidateBeforeCall(subject, limit, offset, _callback);
        final Type localVarReturnType = new TypeToken<List<PreviousConsentSession>>() {
        }.getType();
        this.localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    /**
     * Build call for listTrustedJwtGrantIssuers
     *
     * @param issuer    If optional \&quot;issuer\&quot; is supplied, only jwt-bearer grants with this issuer will be
     *                  returned. (optional)
     * @param limit     The maximum amount of policies returned, upper bound is 500 policies (optional)
     * @param offset    The offset from where to start looking. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> trustedJwtGrantIssuers </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> genericError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call listTrustedJwtGrantIssuersCall(final String issuer, final Long limit, final Long offset, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        final String[] localBasePaths = new String[]{};

        // Determine Base Path to Use
        if (this.localCustomBaseUrl != null) {
            basePath = this.localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[this.localHostIndex];
        } else {
            basePath = null;
        }

        final Object localVarPostBody = null;

        // create path and map variables
        final String localVarPath = "/trust/grants/jwt-bearer/issuers";

        final List<Pair> localVarQueryParams = new ArrayList<>();
        final List<Pair> localVarCollectionQueryParams = new ArrayList<>();
        final Map<String, String> localVarHeaderParams = new HashMap<>();
        final Map<String, String> localVarCookieParams = new HashMap<>();
        final Map<String, Object> localVarFormParams = new HashMap<>();

        if (issuer != null) {
            localVarQueryParams.addAll(this.localVarApiClient.parameterToPair("issuer", issuer));
        }

        if (limit != null) {
            localVarQueryParams.addAll(this.localVarApiClient.parameterToPair("limit", limit));
        }

        if (offset != null) {
            localVarQueryParams.addAll(this.localVarApiClient.parameterToPair("offset", offset));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = this.localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = this.localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        final String[] localVarAuthNames = new String[]{};
        return this.localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listTrustedJwtGrantIssuersValidateBeforeCall(final String issuer, final Long limit, final Long offset, final ApiCallback _callback) throws ApiException {


        final okhttp3.Call localVarCall = this.listTrustedJwtGrantIssuersCall(issuer, limit, offset, _callback);
        return localVarCall;

    }

    /**
     * List Trusted OAuth2 JWT Bearer Grant Type Issuers Use this endpoint to list all trusted JWT Bearer Grant Type
     * Issuers.
     *
     * @param issuer If optional \&quot;issuer\&quot; is supplied, only jwt-bearer grants with this issuer will be
     *               returned. (optional)
     * @param limit  The maximum amount of policies returned, upper bound is 500 policies (optional)
     * @param offset The offset from where to start looking. (optional)
     * @return List&lt;TrustedJwtGrantIssuer&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> trustedJwtGrantIssuers </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> genericError </td><td>  -  </td></tr>
     * </table>
     */
    public List<TrustedJwtGrantIssuer> listTrustedJwtGrantIssuers(final String issuer, final Long limit, final Long offset) throws ApiException {
        final ApiResponse<List<TrustedJwtGrantIssuer>> localVarResp = this.listTrustedJwtGrantIssuersWithHttpInfo(issuer, limit, offset);
        return localVarResp.getData();
    }

    /**
     * List Trusted OAuth2 JWT Bearer Grant Type Issuers Use this endpoint to list all trusted JWT Bearer Grant Type
     * Issuers.
     *
     * @param issuer If optional \&quot;issuer\&quot; is supplied, only jwt-bearer grants with this issuer will be
     *               returned. (optional)
     * @param limit  The maximum amount of policies returned, upper bound is 500 policies (optional)
     * @param offset The offset from where to start looking. (optional)
     * @return ApiResponse&lt;List&lt;TrustedJwtGrantIssuer&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> trustedJwtGrantIssuers </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> genericError </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<List<TrustedJwtGrantIssuer>> listTrustedJwtGrantIssuersWithHttpInfo(final String issuer, final Long limit, final Long offset) throws ApiException {
        final okhttp3.Call localVarCall = this.listTrustedJwtGrantIssuersValidateBeforeCall(issuer, limit, offset, null);
        final Type localVarReturnType = new TypeToken<List<TrustedJwtGrantIssuer>>() {
        }.getType();
        return this.localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List Trusted OAuth2 JWT Bearer Grant Type Issuers (asynchronously) Use this endpoint to list all trusted JWT
     * Bearer Grant Type Issuers.
     *
     * @param issuer    If optional \&quot;issuer\&quot; is supplied, only jwt-bearer grants with this issuer will be
     *                  returned. (optional)
     * @param limit     The maximum amount of policies returned, upper bound is 500 policies (optional)
     * @param offset    The offset from where to start looking. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> trustedJwtGrantIssuers </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> genericError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call listTrustedJwtGrantIssuersAsync(final String issuer, final Long limit, final Long offset, final ApiCallback<List<TrustedJwtGrantIssuer>> _callback) throws ApiException {

        final okhttp3.Call localVarCall = this.listTrustedJwtGrantIssuersValidateBeforeCall(issuer, limit, offset, _callback);
        final Type localVarReturnType = new TypeToken<List<TrustedJwtGrantIssuer>>() {
        }.getType();
        this.localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    /**
     * Build call for patchOAuth2Client
     *
     * @param id            The id of the OAuth 2.0 Client. (required)
     * @param patchDocument (required)
     * @param _callback     Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> oAuth2Client </td><td>  -  </td></tr>
     * <tr><td> 0 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call patchOAuth2ClientCall(final String id, final List<PatchDocument> patchDocument, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        final String[] localBasePaths = new String[]{};

        // Determine Base Path to Use
        if (this.localCustomBaseUrl != null) {
            basePath = this.localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[this.localHostIndex];
        } else {
            basePath = null;
        }

        final Object localVarPostBody = patchDocument;

        // create path and map variables
        final String localVarPath = "/clients/{id}"
            .replaceAll("\\{" + "id" + "\\}", this.localVarApiClient.escapeString(id));

        final List<Pair> localVarQueryParams = new ArrayList<>();
        final List<Pair> localVarCollectionQueryParams = new ArrayList<>();
        final Map<String, String> localVarHeaderParams = new HashMap<>();
        final Map<String, String> localVarCookieParams = new HashMap<>();
        final Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = this.localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = this.localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        final String[] localVarAuthNames = new String[]{};
        return this.localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call patchOAuth2ClientValidateBeforeCall(final String id, final List<PatchDocument> patchDocument, final ApiCallback _callback) throws ApiException {

        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling patchOAuth2Client(Async)");
        }

        // verify the required parameter 'patchDocument' is set
        if (patchDocument == null) {
            throw new ApiException("Missing the required parameter 'patchDocument' when calling patchOAuth2Client(Async)");
        }


        final okhttp3.Call localVarCall = this.patchOAuth2ClientCall(id, patchDocument, _callback);
        return localVarCall;

    }

    /**
     * Patch an OAuth 2.0 Client Patch an existing OAuth 2.0 Client. If you pass &#x60;client_secret&#x60; the secret
     * will be updated and returned via the API. This is the only time you will be able to retrieve the client secret,
     * so write it down and keep it safe.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows.
     * Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect
     * capabilities.
     *
     * @param id            The id of the OAuth 2.0 Client. (required)
     * @param patchDocument (required)
     * @return OAuth2Client
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> oAuth2Client </td><td>  -  </td></tr>
     * <tr><td> 0 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public OAuth2Client patchOAuth2Client(final String id, final List<PatchDocument> patchDocument) throws ApiException {
        final ApiResponse<OAuth2Client> localVarResp = this.patchOAuth2ClientWithHttpInfo(id, patchDocument);
        return localVarResp.getData();
    }

    /**
     * Patch an OAuth 2.0 Client Patch an existing OAuth 2.0 Client. If you pass &#x60;client_secret&#x60; the secret
     * will be updated and returned via the API. This is the only time you will be able to retrieve the client secret,
     * so write it down and keep it safe.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows.
     * Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect
     * capabilities.
     *
     * @param id            The id of the OAuth 2.0 Client. (required)
     * @param patchDocument (required)
     * @return ApiResponse&lt;OAuth2Client&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> oAuth2Client </td><td>  -  </td></tr>
     * <tr><td> 0 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<OAuth2Client> patchOAuth2ClientWithHttpInfo(final String id, final List<PatchDocument> patchDocument) throws ApiException {
        final okhttp3.Call localVarCall = this.patchOAuth2ClientValidateBeforeCall(id, patchDocument, null);
        final Type localVarReturnType = new TypeToken<OAuth2Client>() {
        }.getType();
        return this.localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Patch an OAuth 2.0 Client (asynchronously) Patch an existing OAuth 2.0 Client. If you pass
     * &#x60;client_secret&#x60; the secret will be updated and returned via the API. This is the only time you will be
     * able to retrieve the client secret, so write it down and keep it safe.  OAuth 2.0 clients are used to perform
     * OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to
     * consume your OAuth 2.0 or OpenID Connect capabilities.
     *
     * @param id            The id of the OAuth 2.0 Client. (required)
     * @param patchDocument (required)
     * @param _callback     The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> oAuth2Client </td><td>  -  </td></tr>
     * <tr><td> 0 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call patchOAuth2ClientAsync(final String id, final List<PatchDocument> patchDocument, final ApiCallback<OAuth2Client> _callback) throws ApiException {

        final okhttp3.Call localVarCall = this.patchOAuth2ClientValidateBeforeCall(id, patchDocument, _callback);
        final Type localVarReturnType = new TypeToken<OAuth2Client>() {
        }.getType();
        this.localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    /**
     * Build call for rejectConsentRequest
     *
     * @param consentChallenge (required)
     * @param rejectRequest    (optional)
     * @param _callback        Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> completedRequest </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call rejectConsentRequestCall(final String consentChallenge, final RejectRequest rejectRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        final String[] localBasePaths = new String[]{};

        // Determine Base Path to Use
        if (this.localCustomBaseUrl != null) {
            basePath = this.localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[this.localHostIndex];
        } else {
            basePath = null;
        }

        final Object localVarPostBody = rejectRequest;

        // create path and map variables
        final String localVarPath = "/oauth2/auth/requests/consent/reject";

        final List<Pair> localVarQueryParams = new ArrayList<>();
        final List<Pair> localVarCollectionQueryParams = new ArrayList<>();
        final Map<String, String> localVarHeaderParams = new HashMap<>();
        final Map<String, String> localVarCookieParams = new HashMap<>();
        final Map<String, Object> localVarFormParams = new HashMap<>();

        if (consentChallenge != null) {
            localVarQueryParams.addAll(this.localVarApiClient.parameterToPair("consent_challenge", consentChallenge));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = this.localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = this.localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        final String[] localVarAuthNames = new String[]{};
        return this.localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call rejectConsentRequestValidateBeforeCall(final String consentChallenge, final RejectRequest rejectRequest, final ApiCallback _callback) throws ApiException {

        // verify the required parameter 'consentChallenge' is set
        if (consentChallenge == null) {
            throw new ApiException("Missing the required parameter 'consentChallenge' when calling rejectConsentRequest(Async)");
        }


        final okhttp3.Call localVarCall = this.rejectConsentRequestCall(consentChallenge, rejectRequest, _callback);
        return localVarCall;

    }

    /**
     * Reject a Consent Request When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra
     * asks the login provider to authenticate the subject and then tell ORY Hydra now about it. If the subject
     * authenticated, he/she must now be asked if the OAuth 2.0 Client which initiated the flow should be allowed to
     * access the resources on the subject&#39;s behalf.  The consent provider which handles this request and is a web
     * app implemented and hosted by you. It shows a subject interface which asks the subject to grant or deny the
     * client access to the requested scope (\&quot;Application my-dropbox-app wants write access to all your private
     * files\&quot;).  The consent challenge is appended to the consent provider&#39;s URL to which the subject&#39;s
     * user-agent (browser) is redirected to. The consent provider uses that challenge to fetch information on the
     * OAuth2 request and then tells ORY Hydra if the subject accepted or rejected the request.  This endpoint tells ORY
     * Hydra that the subject has not authorized the OAuth 2.0 client to access resources on his/her behalf. The consent
     * provider must include a reason why the consent was not granted.  The response contains a redirect URL which the
     * consent provider should redirect the user-agent to.
     *
     * @param consentChallenge (required)
     * @param rejectRequest    (optional)
     * @return CompletedRequest
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> completedRequest </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public CompletedRequest rejectConsentRequest(final String consentChallenge, final RejectRequest rejectRequest) throws ApiException {
        final ApiResponse<CompletedRequest> localVarResp = this.rejectConsentRequestWithHttpInfo(consentChallenge, rejectRequest);
        return localVarResp.getData();
    }

    /**
     * Reject a Consent Request When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra
     * asks the login provider to authenticate the subject and then tell ORY Hydra now about it. If the subject
     * authenticated, he/she must now be asked if the OAuth 2.0 Client which initiated the flow should be allowed to
     * access the resources on the subject&#39;s behalf.  The consent provider which handles this request and is a web
     * app implemented and hosted by you. It shows a subject interface which asks the subject to grant or deny the
     * client access to the requested scope (\&quot;Application my-dropbox-app wants write access to all your private
     * files\&quot;).  The consent challenge is appended to the consent provider&#39;s URL to which the subject&#39;s
     * user-agent (browser) is redirected to. The consent provider uses that challenge to fetch information on the
     * OAuth2 request and then tells ORY Hydra if the subject accepted or rejected the request.  This endpoint tells ORY
     * Hydra that the subject has not authorized the OAuth 2.0 client to access resources on his/her behalf. The consent
     * provider must include a reason why the consent was not granted.  The response contains a redirect URL which the
     * consent provider should redirect the user-agent to.
     *
     * @param consentChallenge (required)
     * @param rejectRequest    (optional)
     * @return ApiResponse&lt;CompletedRequest&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> completedRequest </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<CompletedRequest> rejectConsentRequestWithHttpInfo(final String consentChallenge, final RejectRequest rejectRequest) throws ApiException {
        final okhttp3.Call localVarCall = this.rejectConsentRequestValidateBeforeCall(consentChallenge, rejectRequest, null);
        final Type localVarReturnType = new TypeToken<CompletedRequest>() {
        }.getType();
        return this.localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Reject a Consent Request (asynchronously) When an authorization code, hybrid, or implicit OAuth 2.0 Flow is
     * initiated, ORY Hydra asks the login provider to authenticate the subject and then tell ORY Hydra now about it. If
     * the subject authenticated, he/she must now be asked if the OAuth 2.0 Client which initiated the flow should be
     * allowed to access the resources on the subject&#39;s behalf.  The consent provider which handles this request and
     * is a web app implemented and hosted by you. It shows a subject interface which asks the subject to grant or deny
     * the client access to the requested scope (\&quot;Application my-dropbox-app wants write access to all your
     * private files\&quot;).  The consent challenge is appended to the consent provider&#39;s URL to which the
     * subject&#39;s user-agent (browser) is redirected to. The consent provider uses that challenge to fetch
     * information on the OAuth2 request and then tells ORY Hydra if the subject accepted or rejected the request.  This
     * endpoint tells ORY Hydra that the subject has not authorized the OAuth 2.0 client to access resources on his/her
     * behalf. The consent provider must include a reason why the consent was not granted.  The response contains a
     * redirect URL which the consent provider should redirect the user-agent to.
     *
     * @param consentChallenge (required)
     * @param rejectRequest    (optional)
     * @param _callback        The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> completedRequest </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call rejectConsentRequestAsync(final String consentChallenge, final RejectRequest rejectRequest, final ApiCallback<CompletedRequest> _callback) throws ApiException {

        final okhttp3.Call localVarCall = this.rejectConsentRequestValidateBeforeCall(consentChallenge, rejectRequest, _callback);
        final Type localVarReturnType = new TypeToken<CompletedRequest>() {
        }.getType();
        this.localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    /**
     * Build call for rejectLoginRequest
     *
     * @param loginChallenge (required)
     * @param rejectRequest  (optional)
     * @param _callback      Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> completedRequest </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call rejectLoginRequestCall(final String loginChallenge, final RejectRequest rejectRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        final String[] localBasePaths = new String[]{};

        // Determine Base Path to Use
        if (this.localCustomBaseUrl != null) {
            basePath = this.localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[this.localHostIndex];
        } else {
            basePath = null;
        }

        final Object localVarPostBody = rejectRequest;

        // create path and map variables
        final String localVarPath = "/oauth2/auth/requests/login/reject";

        final List<Pair> localVarQueryParams = new ArrayList<>();
        final List<Pair> localVarCollectionQueryParams = new ArrayList<>();
        final Map<String, String> localVarHeaderParams = new HashMap<>();
        final Map<String, String> localVarCookieParams = new HashMap<>();
        final Map<String, Object> localVarFormParams = new HashMap<>();

        if (loginChallenge != null) {
            localVarQueryParams.addAll(this.localVarApiClient.parameterToPair("login_challenge", loginChallenge));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = this.localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = this.localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        final String[] localVarAuthNames = new String[]{};
        return this.localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call rejectLoginRequestValidateBeforeCall(final String loginChallenge, final RejectRequest rejectRequest, final ApiCallback _callback) throws ApiException {

        // verify the required parameter 'loginChallenge' is set
        if (loginChallenge == null) {
            throw new ApiException("Missing the required parameter 'loginChallenge' when calling rejectLoginRequest(Async)");
        }


        final okhttp3.Call localVarCall = this.rejectLoginRequestCall(loginChallenge, rejectRequest, _callback);
        return localVarCall;

    }

    /**
     * Reject a Login Request When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra
     * asks the login provider (sometimes called \&quot;identity provider\&quot;) to authenticate the subject and then
     * tell ORY Hydra now about it. The login provider is an web-app you write and host, and it must be able to
     * authenticate (\&quot;show the subject a login screen\&quot;) a subject (in OAuth2 the proper name for subject is
     * \&quot;resource owner\&quot;).  The authentication challenge is appended to the login provider URL to which the
     * subject&#39;s user-agent (browser) is redirected to. The login provider uses that challenge to fetch information
     * on the OAuth2 request and then accept or reject the requested authentication process.  This endpoint tells ORY
     * Hydra that the subject has not authenticated and includes a reason why the authentication was be denied.  The
     * response contains a redirect URL which the login provider should redirect the user-agent to.
     *
     * @param loginChallenge (required)
     * @param rejectRequest  (optional)
     * @return CompletedRequest
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> completedRequest </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public CompletedRequest rejectLoginRequest(final String loginChallenge, final RejectRequest rejectRequest) throws ApiException {
        final ApiResponse<CompletedRequest> localVarResp = this.rejectLoginRequestWithHttpInfo(loginChallenge, rejectRequest);
        return localVarResp.getData();
    }

    /**
     * Reject a Login Request When an authorization code, hybrid, or implicit OAuth 2.0 Flow is initiated, ORY Hydra
     * asks the login provider (sometimes called \&quot;identity provider\&quot;) to authenticate the subject and then
     * tell ORY Hydra now about it. The login provider is an web-app you write and host, and it must be able to
     * authenticate (\&quot;show the subject a login screen\&quot;) a subject (in OAuth2 the proper name for subject is
     * \&quot;resource owner\&quot;).  The authentication challenge is appended to the login provider URL to which the
     * subject&#39;s user-agent (browser) is redirected to. The login provider uses that challenge to fetch information
     * on the OAuth2 request and then accept or reject the requested authentication process.  This endpoint tells ORY
     * Hydra that the subject has not authenticated and includes a reason why the authentication was be denied.  The
     * response contains a redirect URL which the login provider should redirect the user-agent to.
     *
     * @param loginChallenge (required)
     * @param rejectRequest  (optional)
     * @return ApiResponse&lt;CompletedRequest&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> completedRequest </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<CompletedRequest> rejectLoginRequestWithHttpInfo(final String loginChallenge, final RejectRequest rejectRequest) throws ApiException {
        final okhttp3.Call localVarCall = this.rejectLoginRequestValidateBeforeCall(loginChallenge, rejectRequest, null);
        final Type localVarReturnType = new TypeToken<CompletedRequest>() {
        }.getType();
        return this.localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Reject a Login Request (asynchronously) When an authorization code, hybrid, or implicit OAuth 2.0 Flow is
     * initiated, ORY Hydra asks the login provider (sometimes called \&quot;identity provider\&quot;) to authenticate
     * the subject and then tell ORY Hydra now about it. The login provider is an web-app you write and host, and it
     * must be able to authenticate (\&quot;show the subject a login screen\&quot;) a subject (in OAuth2 the proper name
     * for subject is \&quot;resource owner\&quot;).  The authentication challenge is appended to the login provider URL
     * to which the subject&#39;s user-agent (browser) is redirected to. The login provider uses that challenge to fetch
     * information on the OAuth2 request and then accept or reject the requested authentication process.  This endpoint
     * tells ORY Hydra that the subject has not authenticated and includes a reason why the authentication was be
     * denied.  The response contains a redirect URL which the login provider should redirect the user-agent to.
     *
     * @param loginChallenge (required)
     * @param rejectRequest  (optional)
     * @param _callback      The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> completedRequest </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call rejectLoginRequestAsync(final String loginChallenge, final RejectRequest rejectRequest, final ApiCallback<CompletedRequest> _callback) throws ApiException {

        final okhttp3.Call localVarCall = this.rejectLoginRequestValidateBeforeCall(loginChallenge, rejectRequest, _callback);
        final Type localVarReturnType = new TypeToken<CompletedRequest>() {
        }.getType();
        this.localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    /**
     * Build call for rejectLogoutRequest
     *
     * @param logoutChallenge (required)
     * @param rejectRequest   (optional)
     * @param _callback       Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Empty responses are sent when, for example, resources are deleted. The HTTP status code
     * for empty responses is typically 201. </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call rejectLogoutRequestCall(final String logoutChallenge, final RejectRequest rejectRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        final String[] localBasePaths = new String[]{};

        // Determine Base Path to Use
        if (this.localCustomBaseUrl != null) {
            basePath = this.localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[this.localHostIndex];
        } else {
            basePath = null;
        }

        final Object localVarPostBody = rejectRequest;

        // create path and map variables
        final String localVarPath = "/oauth2/auth/requests/logout/reject";

        final List<Pair> localVarQueryParams = new ArrayList<>();
        final List<Pair> localVarCollectionQueryParams = new ArrayList<>();
        final Map<String, String> localVarHeaderParams = new HashMap<>();
        final Map<String, String> localVarCookieParams = new HashMap<>();
        final Map<String, Object> localVarFormParams = new HashMap<>();

        if (logoutChallenge != null) {
            localVarQueryParams.addAll(this.localVarApiClient.parameterToPair("logout_challenge", logoutChallenge));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = this.localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json", "application/x-www-form-urlencoded"
        };
        final String localVarContentType = this.localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        final String[] localVarAuthNames = new String[]{};
        return this.localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call rejectLogoutRequestValidateBeforeCall(final String logoutChallenge, final RejectRequest rejectRequest, final ApiCallback _callback) throws ApiException {

        // verify the required parameter 'logoutChallenge' is set
        if (logoutChallenge == null) {
            throw new ApiException("Missing the required parameter 'logoutChallenge' when calling rejectLogoutRequest(Async)");
        }


        final okhttp3.Call localVarCall = this.rejectLogoutRequestCall(logoutChallenge, rejectRequest, _callback);
        return localVarCall;

    }

    /**
     * Reject a Logout Request When a user or an application requests ORY Hydra to log out a user, this endpoint is used
     * to deny that logout request. No body is required.  The response is empty as the logout provider has to chose what
     * action to perform next.
     *
     * @param logoutChallenge (required)
     * @param rejectRequest   (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Empty responses are sent when, for example, resources are deleted. The HTTP status code
     * for empty responses is typically 201. </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public void rejectLogoutRequest(final String logoutChallenge, final RejectRequest rejectRequest) throws ApiException {
        this.rejectLogoutRequestWithHttpInfo(logoutChallenge, rejectRequest);
    }

    /**
     * Reject a Logout Request When a user or an application requests ORY Hydra to log out a user, this endpoint is used
     * to deny that logout request. No body is required.  The response is empty as the logout provider has to chose what
     * action to perform next.
     *
     * @param logoutChallenge (required)
     * @param rejectRequest   (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Empty responses are sent when, for example, resources are deleted. The HTTP status code
     * for empty responses is typically 201. </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> rejectLogoutRequestWithHttpInfo(final String logoutChallenge, final RejectRequest rejectRequest) throws ApiException {
        final okhttp3.Call localVarCall = this.rejectLogoutRequestValidateBeforeCall(logoutChallenge, rejectRequest, null);
        return this.localVarApiClient.execute(localVarCall);
    }

    /**
     * Reject a Logout Request (asynchronously) When a user or an application requests ORY Hydra to log out a user, this
     * endpoint is used to deny that logout request. No body is required.  The response is empty as the logout provider
     * has to chose what action to perform next.
     *
     * @param logoutChallenge (required)
     * @param rejectRequest   (optional)
     * @param _callback       The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Empty responses are sent when, for example, resources are deleted. The HTTP status code
     * for empty responses is typically 201. </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call rejectLogoutRequestAsync(final String logoutChallenge, final RejectRequest rejectRequest, final ApiCallback<Void> _callback) throws ApiException {

        final okhttp3.Call localVarCall = this.rejectLogoutRequestValidateBeforeCall(logoutChallenge, rejectRequest, _callback);
        this.localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    /**
     * Build call for revokeAuthenticationSession
     *
     * @param subject   (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Empty responses are sent when, for example, resources are deleted. The HTTP status code
     * for empty responses is typically 201. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call revokeAuthenticationSessionCall(final String subject, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        final String[] localBasePaths = new String[]{};

        // Determine Base Path to Use
        if (this.localCustomBaseUrl != null) {
            basePath = this.localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[this.localHostIndex];
        } else {
            basePath = null;
        }

        final Object localVarPostBody = null;

        // create path and map variables
        final String localVarPath = "/oauth2/auth/sessions/login";

        final List<Pair> localVarQueryParams = new ArrayList<>();
        final List<Pair> localVarCollectionQueryParams = new ArrayList<>();
        final Map<String, String> localVarHeaderParams = new HashMap<>();
        final Map<String, String> localVarCookieParams = new HashMap<>();
        final Map<String, Object> localVarFormParams = new HashMap<>();

        if (subject != null) {
            localVarQueryParams.addAll(this.localVarApiClient.parameterToPair("subject", subject));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = this.localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = this.localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        final String[] localVarAuthNames = new String[]{};
        return this.localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call revokeAuthenticationSessionValidateBeforeCall(final String subject, final ApiCallback _callback) throws ApiException {

        // verify the required parameter 'subject' is set
        if (subject == null) {
            throw new ApiException("Missing the required parameter 'subject' when calling revokeAuthenticationSession(Async)");
        }


        final okhttp3.Call localVarCall = this.revokeAuthenticationSessionCall(subject, _callback);
        return localVarCall;

    }

    /**
     * Invalidates All Login Sessions of a Certain User Invalidates a Subject&#39;s Authentication Session This endpoint
     * invalidates a subject&#39;s authentication session. After revoking the authentication session, the subject has to
     * re-authenticate at ORY Hydra. This endpoint does not invalidate any tokens and does not work with OpenID Connect
     * Front- or Back-channel logout.
     *
     * @param subject (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Empty responses are sent when, for example, resources are deleted. The HTTP status code
     * for empty responses is typically 201. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public void revokeAuthenticationSession(final String subject) throws ApiException {
        this.revokeAuthenticationSessionWithHttpInfo(subject);
    }

    /**
     * Invalidates All Login Sessions of a Certain User Invalidates a Subject&#39;s Authentication Session This endpoint
     * invalidates a subject&#39;s authentication session. After revoking the authentication session, the subject has to
     * re-authenticate at ORY Hydra. This endpoint does not invalidate any tokens and does not work with OpenID Connect
     * Front- or Back-channel logout.
     *
     * @param subject (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Empty responses are sent when, for example, resources are deleted. The HTTP status code
     * for empty responses is typically 201. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> revokeAuthenticationSessionWithHttpInfo(final String subject) throws ApiException {
        final okhttp3.Call localVarCall = this.revokeAuthenticationSessionValidateBeforeCall(subject, null);
        return this.localVarApiClient.execute(localVarCall);
    }

    /**
     * Invalidates All Login Sessions of a Certain User Invalidates a Subject&#39;s Authentication Session
     * (asynchronously) This endpoint invalidates a subject&#39;s authentication session. After revoking the
     * authentication session, the subject has to re-authenticate at ORY Hydra. This endpoint does not invalidate any
     * tokens and does not work with OpenID Connect Front- or Back-channel logout.
     *
     * @param subject   (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Empty responses are sent when, for example, resources are deleted. The HTTP status code
     * for empty responses is typically 201. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call revokeAuthenticationSessionAsync(final String subject, final ApiCallback<Void> _callback) throws ApiException {

        final okhttp3.Call localVarCall = this.revokeAuthenticationSessionValidateBeforeCall(subject, _callback);
        this.localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    /**
     * Build call for revokeConsentSessions
     *
     * @param subject   The subject (Subject) who&#39;s consent sessions should be deleted. (required)
     * @param client    If set, deletes only those consent sessions by the Subject that have been granted to the
     *                  specified OAuth 2.0 Client ID (optional)
     * @param all       If set to &#x60;?all&#x3D;true&#x60;, deletes all consent sessions by the Subject that have been
     *                  granted. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Empty responses are sent when, for example, resources are deleted. The HTTP status code
     * for empty responses is typically 201. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call revokeConsentSessionsCall(final String subject, final String client, final Boolean all, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        final String[] localBasePaths = new String[]{};

        // Determine Base Path to Use
        if (this.localCustomBaseUrl != null) {
            basePath = this.localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[this.localHostIndex];
        } else {
            basePath = null;
        }

        final Object localVarPostBody = null;

        // create path and map variables
        final String localVarPath = "/oauth2/auth/sessions/consent";

        final List<Pair> localVarQueryParams = new ArrayList<>();
        final List<Pair> localVarCollectionQueryParams = new ArrayList<>();
        final Map<String, String> localVarHeaderParams = new HashMap<>();
        final Map<String, String> localVarCookieParams = new HashMap<>();
        final Map<String, Object> localVarFormParams = new HashMap<>();

        if (subject != null) {
            localVarQueryParams.addAll(this.localVarApiClient.parameterToPair("subject", subject));
        }

        if (client != null) {
            localVarQueryParams.addAll(this.localVarApiClient.parameterToPair("client", client));
        }

        if (all != null) {
            localVarQueryParams.addAll(this.localVarApiClient.parameterToPair("all", all));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = this.localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {

        };
        final String localVarContentType = this.localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        final String[] localVarAuthNames = new String[]{};
        return this.localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call revokeConsentSessionsValidateBeforeCall(final String subject, final String client, final Boolean all, final ApiCallback _callback) throws ApiException {

        // verify the required parameter 'subject' is set
        if (subject == null) {
            throw new ApiException("Missing the required parameter 'subject' when calling revokeConsentSessions(Async)");
        }


        final okhttp3.Call localVarCall = this.revokeConsentSessionsCall(subject, client, all, _callback);
        return localVarCall;

    }

    /**
     * Revokes Consent Sessions of a Subject for a Specific OAuth 2.0 Client This endpoint revokes a subject&#39;s
     * granted consent sessions for a specific OAuth 2.0 Client and invalidates all associated OAuth 2.0 Access Tokens.
     *
     * @param subject The subject (Subject) who&#39;s consent sessions should be deleted. (required)
     * @param client  If set, deletes only those consent sessions by the Subject that have been granted to the specified
     *                OAuth 2.0 Client ID (optional)
     * @param all     If set to &#x60;?all&#x3D;true&#x60;, deletes all consent sessions by the Subject that have been
     *                granted. (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Empty responses are sent when, for example, resources are deleted. The HTTP status code
     * for empty responses is typically 201. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public void revokeConsentSessions(final String subject, final String client, final Boolean all) throws ApiException {
        this.revokeConsentSessionsWithHttpInfo(subject, client, all);
    }

    /**
     * Revokes Consent Sessions of a Subject for a Specific OAuth 2.0 Client This endpoint revokes a subject&#39;s
     * granted consent sessions for a specific OAuth 2.0 Client and invalidates all associated OAuth 2.0 Access Tokens.
     *
     * @param subject The subject (Subject) who&#39;s consent sessions should be deleted. (required)
     * @param client  If set, deletes only those consent sessions by the Subject that have been granted to the specified
     *                OAuth 2.0 Client ID (optional)
     * @param all     If set to &#x60;?all&#x3D;true&#x60;, deletes all consent sessions by the Subject that have been
     *                granted. (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Empty responses are sent when, for example, resources are deleted. The HTTP status code
     * for empty responses is typically 201. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> revokeConsentSessionsWithHttpInfo(final String subject, final String client, final Boolean all) throws ApiException {
        final okhttp3.Call localVarCall = this.revokeConsentSessionsValidateBeforeCall(subject, client, all, null);
        return this.localVarApiClient.execute(localVarCall);
    }

    /**
     * Revokes Consent Sessions of a Subject for a Specific OAuth 2.0 Client (asynchronously) This endpoint revokes a
     * subject&#39;s granted consent sessions for a specific OAuth 2.0 Client and invalidates all associated OAuth 2.0
     * Access Tokens.
     *
     * @param subject   The subject (Subject) who&#39;s consent sessions should be deleted. (required)
     * @param client    If set, deletes only those consent sessions by the Subject that have been granted to the
     *                  specified OAuth 2.0 Client ID (optional)
     * @param all       If set to &#x60;?all&#x3D;true&#x60;, deletes all consent sessions by the Subject that have been
     *                  granted. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Empty responses are sent when, for example, resources are deleted. The HTTP status code
     * for empty responses is typically 201. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call revokeConsentSessionsAsync(final String subject, final String client, final Boolean all, final ApiCallback<Void> _callback) throws ApiException {

        final okhttp3.Call localVarCall = this.revokeConsentSessionsValidateBeforeCall(subject, client, all, _callback);
        this.localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    /**
     * Build call for trustJwtGrantIssuer
     *
     * @param trustJwtGrantIssuerBody (optional)
     * @param _callback               Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 201 </td><td> trustedJwtGrantIssuer </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> genericError </td><td>  -  </td></tr>
     * <tr><td> 409 </td><td> genericError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> genericError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call trustJwtGrantIssuerCall(final TrustJwtGrantIssuerBody trustJwtGrantIssuerBody, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        final String[] localBasePaths = new String[]{};

        // Determine Base Path to Use
        if (this.localCustomBaseUrl != null) {
            basePath = this.localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[this.localHostIndex];
        } else {
            basePath = null;
        }

        final Object localVarPostBody = trustJwtGrantIssuerBody;

        // create path and map variables
        final String localVarPath = "/trust/grants/jwt-bearer/issuers";

        final List<Pair> localVarQueryParams = new ArrayList<>();
        final List<Pair> localVarCollectionQueryParams = new ArrayList<>();
        final Map<String, String> localVarHeaderParams = new HashMap<>();
        final Map<String, String> localVarCookieParams = new HashMap<>();
        final Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = this.localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = this.localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        final String[] localVarAuthNames = new String[]{};
        return this.localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call trustJwtGrantIssuerValidateBeforeCall(final TrustJwtGrantIssuerBody trustJwtGrantIssuerBody, final ApiCallback _callback) throws ApiException {


        final okhttp3.Call localVarCall = this.trustJwtGrantIssuerCall(trustJwtGrantIssuerBody, _callback);
        return localVarCall;

    }

    /**
     * Trust an OAuth2 JWT Bearer Grant Type Issuer Use this endpoint to establish a trust relationship for a JWT issuer
     * to perform JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants
     * [RFC7523](https://datatracker.ietf.org/doc/html/rfc7523).
     *
     * @param trustJwtGrantIssuerBody (optional)
     * @return TrustedJwtGrantIssuer
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 201 </td><td> trustedJwtGrantIssuer </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> genericError </td><td>  -  </td></tr>
     * <tr><td> 409 </td><td> genericError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> genericError </td><td>  -  </td></tr>
     * </table>
     */
    public TrustedJwtGrantIssuer trustJwtGrantIssuer(final TrustJwtGrantIssuerBody trustJwtGrantIssuerBody) throws ApiException {
        final ApiResponse<TrustedJwtGrantIssuer> localVarResp = this.trustJwtGrantIssuerWithHttpInfo(trustJwtGrantIssuerBody);
        return localVarResp.getData();
    }

    /**
     * Trust an OAuth2 JWT Bearer Grant Type Issuer Use this endpoint to establish a trust relationship for a JWT issuer
     * to perform JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants
     * [RFC7523](https://datatracker.ietf.org/doc/html/rfc7523).
     *
     * @param trustJwtGrantIssuerBody (optional)
     * @return ApiResponse&lt;TrustedJwtGrantIssuer&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 201 </td><td> trustedJwtGrantIssuer </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> genericError </td><td>  -  </td></tr>
     * <tr><td> 409 </td><td> genericError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> genericError </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<TrustedJwtGrantIssuer> trustJwtGrantIssuerWithHttpInfo(final TrustJwtGrantIssuerBody trustJwtGrantIssuerBody) throws ApiException {
        final okhttp3.Call localVarCall = this.trustJwtGrantIssuerValidateBeforeCall(trustJwtGrantIssuerBody, null);
        final Type localVarReturnType = new TypeToken<TrustedJwtGrantIssuer>() {
        }.getType();
        return this.localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Trust an OAuth2 JWT Bearer Grant Type Issuer (asynchronously) Use this endpoint to establish a trust relationship
     * for a JWT issuer to perform JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization
     * Grants [RFC7523](https://datatracker.ietf.org/doc/html/rfc7523).
     *
     * @param trustJwtGrantIssuerBody (optional)
     * @param _callback               The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 201 </td><td> trustedJwtGrantIssuer </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> genericError </td><td>  -  </td></tr>
     * <tr><td> 409 </td><td> genericError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> genericError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call trustJwtGrantIssuerAsync(final TrustJwtGrantIssuerBody trustJwtGrantIssuerBody, final ApiCallback<TrustedJwtGrantIssuer> _callback) throws ApiException {

        final okhttp3.Call localVarCall = this.trustJwtGrantIssuerValidateBeforeCall(trustJwtGrantIssuerBody, _callback);
        final Type localVarReturnType = new TypeToken<TrustedJwtGrantIssuer>() {
        }.getType();
        this.localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    /**
     * Build call for updateJsonWebKey
     *
     * @param kid        The kid of the desired key (required)
     * @param set        The set (required)
     * @param jsONWebKey (optional)
     * @param _callback  Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> JSONWebKey </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateJsonWebKeyCall(final String kid, final String set, final JSONWebKey jsONWebKey, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        final String[] localBasePaths = new String[]{};

        // Determine Base Path to Use
        if (this.localCustomBaseUrl != null) {
            basePath = this.localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[this.localHostIndex];
        } else {
            basePath = null;
        }

        final Object localVarPostBody = jsONWebKey;

        // create path and map variables
        final String localVarPath = "/keys/{set}/{kid}"
            .replaceAll("\\{" + "kid" + "\\}", this.localVarApiClient.escapeString(kid))
            .replaceAll("\\{" + "set" + "\\}", this.localVarApiClient.escapeString(set));

        final List<Pair> localVarQueryParams = new ArrayList<>();
        final List<Pair> localVarCollectionQueryParams = new ArrayList<>();
        final Map<String, String> localVarHeaderParams = new HashMap<>();
        final Map<String, String> localVarCookieParams = new HashMap<>();
        final Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = this.localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = this.localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        final String[] localVarAuthNames = new String[]{};
        return this.localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateJsonWebKeyValidateBeforeCall(final String kid, final String set, final JSONWebKey jsONWebKey, final ApiCallback _callback) throws ApiException {

        // verify the required parameter 'kid' is set
        if (kid == null) {
            throw new ApiException("Missing the required parameter 'kid' when calling updateJsonWebKey(Async)");
        }

        // verify the required parameter 'set' is set
        if (set == null) {
            throw new ApiException("Missing the required parameter 'set' when calling updateJsonWebKey(Async)");
        }


        final okhttp3.Call localVarCall = this.updateJsonWebKeyCall(kid, set, jsONWebKey, _callback);
        return localVarCall;

    }

    /**
     * Update a JSON Web Key Use this method if you do not want to let Hydra generate the JWKs for you, but instead save
     * your own.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a
     * cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified
     * by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web
     * Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
     *
     * @param kid        The kid of the desired key (required)
     * @param set        The set (required)
     * @param jsONWebKey (optional)
     * @return JSONWebKey
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> JSONWebKey </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public JSONWebKey updateJsonWebKey(final String kid, final String set, final JSONWebKey jsONWebKey) throws ApiException {
        final ApiResponse<JSONWebKey> localVarResp = this.updateJsonWebKeyWithHttpInfo(kid, set, jsONWebKey);
        return localVarResp.getData();
    }

    /**
     * Update a JSON Web Key Use this method if you do not want to let Hydra generate the JWKs for you, but instead save
     * your own.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a
     * cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified
     * by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web
     * Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
     *
     * @param kid        The kid of the desired key (required)
     * @param set        The set (required)
     * @param jsONWebKey (optional)
     * @return ApiResponse&lt;JSONWebKey&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> JSONWebKey </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<JSONWebKey> updateJsonWebKeyWithHttpInfo(final String kid, final String set, final JSONWebKey jsONWebKey) throws ApiException {
        final okhttp3.Call localVarCall = this.updateJsonWebKeyValidateBeforeCall(kid, set, jsONWebKey, null);
        final Type localVarReturnType = new TypeToken<JSONWebKey>() {
        }.getType();
        return this.localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update a JSON Web Key (asynchronously) Use this method if you do not want to let Hydra generate the JWKs for you,
     * but instead save your own.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that
     * represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key
     * is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS
     * and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
     *
     * @param kid        The kid of the desired key (required)
     * @param set        The set (required)
     * @param jsONWebKey (optional)
     * @param _callback  The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> JSONWebKey </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateJsonWebKeyAsync(final String kid, final String set, final JSONWebKey jsONWebKey, final ApiCallback<JSONWebKey> _callback) throws ApiException {

        final okhttp3.Call localVarCall = this.updateJsonWebKeyValidateBeforeCall(kid, set, jsONWebKey, _callback);
        final Type localVarReturnType = new TypeToken<JSONWebKey>() {
        }.getType();
        this.localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    /**
     * Build call for updateJsonWebKeySet
     *
     * @param set           The set (required)
     * @param jsONWebKeySet (optional)
     * @param _callback     Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> JSONWebKeySet </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateJsonWebKeySetCall(final String set, final JSONWebKeySet jsONWebKeySet, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        final String[] localBasePaths = new String[]{};

        // Determine Base Path to Use
        if (this.localCustomBaseUrl != null) {
            basePath = this.localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[this.localHostIndex];
        } else {
            basePath = null;
        }

        final Object localVarPostBody = jsONWebKeySet;

        // create path and map variables
        final String localVarPath = "/keys/{set}"
            .replaceAll("\\{" + "set" + "\\}", this.localVarApiClient.escapeString(set));

        final List<Pair> localVarQueryParams = new ArrayList<>();
        final List<Pair> localVarCollectionQueryParams = new ArrayList<>();
        final Map<String, String> localVarHeaderParams = new HashMap<>();
        final Map<String, String> localVarCookieParams = new HashMap<>();
        final Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = this.localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = this.localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        final String[] localVarAuthNames = new String[]{};
        return this.localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateJsonWebKeySetValidateBeforeCall(final String set, final JSONWebKeySet jsONWebKeySet, final ApiCallback _callback) throws ApiException {

        // verify the required parameter 'set' is set
        if (set == null) {
            throw new ApiException("Missing the required parameter 'set' when calling updateJsonWebKeySet(Async)");
        }


        final okhttp3.Call localVarCall = this.updateJsonWebKeySetCall(set, jsONWebKeySet, _callback);
        return localVarCall;

    }

    /**
     * Update a JSON Web Key Set Use this method if you do not want to let Hydra generate the JWKs for you, but instead
     * save your own.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a
     * cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified
     * by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web
     * Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
     *
     * @param set           The set (required)
     * @param jsONWebKeySet (optional)
     * @return JSONWebKeySet
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> JSONWebKeySet </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public JSONWebKeySet updateJsonWebKeySet(final String set, final JSONWebKeySet jsONWebKeySet) throws ApiException {
        final ApiResponse<JSONWebKeySet> localVarResp = this.updateJsonWebKeySetWithHttpInfo(set, jsONWebKeySet);
        return localVarResp.getData();
    }

    /**
     * Update a JSON Web Key Set Use this method if you do not want to let Hydra generate the JWKs for you, but instead
     * save your own.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that represents a
     * cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key is identified
     * by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS and JSON Web
     * Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
     *
     * @param set           The set (required)
     * @param jsONWebKeySet (optional)
     * @return ApiResponse&lt;JSONWebKeySet&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> JSONWebKeySet </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<JSONWebKeySet> updateJsonWebKeySetWithHttpInfo(final String set, final JSONWebKeySet jsONWebKeySet) throws ApiException {
        final okhttp3.Call localVarCall = this.updateJsonWebKeySetValidateBeforeCall(set, jsONWebKeySet, null);
        final Type localVarReturnType = new TypeToken<JSONWebKeySet>() {
        }.getType();
        return this.localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update a JSON Web Key Set (asynchronously) Use this method if you do not want to let Hydra generate the JWKs for
     * you, but instead save your own.  A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure that
     * represents a cryptographic key. A JWK Set is a JSON data structure that represents a set of JWKs. A JSON Web Key
     * is identified by its set and key id. ORY Hydra uses this functionality to store cryptographic keys used for TLS
     * and JSON Web Tokens (such as OpenID Connect ID tokens), and allows storing user-defined keys as well.
     *
     * @param set           The set (required)
     * @param jsONWebKeySet (optional)
     * @param _callback     The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> JSONWebKeySet </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> jsonError </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateJsonWebKeySetAsync(final String set, final JSONWebKeySet jsONWebKeySet, final ApiCallback<JSONWebKeySet> _callback) throws ApiException {

        final okhttp3.Call localVarCall = this.updateJsonWebKeySetValidateBeforeCall(set, jsONWebKeySet, _callback);
        final Type localVarReturnType = new TypeToken<JSONWebKeySet>() {
        }.getType();
        this.localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    /**
     * Build call for updateOAuth2Client
     *
     * @param id           The id of the OAuth 2.0 Client. (required)
     * @param oauth2Client (required)
     * @param _callback    Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> oAuth2Client </td><td>  -  </td></tr>
     * <tr><td> 0 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateOAuth2ClientCall(final String id, final OAuth2Client oauth2Client, final ApiCallback _callback) throws ApiException {
        String basePath = null;

        // Operation Servers
        final String[] localBasePaths = new String[]{};

        // Determine Base Path to Use
        if (this.localCustomBaseUrl != null) {
            basePath = this.localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[this.localHostIndex];
        } else {
            basePath = null;
        }

        final Object localVarPostBody = oauth2Client;

        // create path and map variables
        final String localVarPath = "/clients/{id}"
            .replaceAll("\\{" + "id" + "\\}", this.localVarApiClient.escapeString(id));

        final List<Pair> localVarQueryParams = new ArrayList<>();
        final List<Pair> localVarCollectionQueryParams = new ArrayList<>();
        final Map<String, String> localVarHeaderParams = new HashMap<>();
        final Map<String, String> localVarCookieParams = new HashMap<>();
        final Map<String, Object> localVarFormParams = new HashMap<>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = this.localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = this.localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        final String[] localVarAuthNames = new String[]{};
        return this.localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateOAuth2ClientValidateBeforeCall(final String id, final OAuth2Client oauth2Client, final ApiCallback _callback) throws ApiException {

        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling updateOAuth2Client(Async)");
        }

        // verify the required parameter 'oauth2Client' is set
        if (oauth2Client == null) {
            throw new ApiException("Missing the required parameter 'oauth2Client' when calling updateOAuth2Client(Async)");
        }


        final okhttp3.Call localVarCall = this.updateOAuth2ClientCall(id, oauth2Client, _callback);
        return localVarCall;

    }

    /**
     * Update an OAuth 2.0 Client Update an existing OAuth 2.0 Client. If you pass &#x60;client_secret&#x60; the secret
     * will be updated and returned via the API. This is the only time you will be able to retrieve the client secret,
     * so write it down and keep it safe.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows.
     * Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect
     * capabilities.
     *
     * @param id           The id of the OAuth 2.0 Client. (required)
     * @param oauth2Client (required)
     * @return OAuth2Client
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> oAuth2Client </td><td>  -  </td></tr>
     * <tr><td> 0 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public OAuth2Client updateOAuth2Client(final String id, final OAuth2Client oauth2Client) throws ApiException {
        final ApiResponse<OAuth2Client> localVarResp = this.updateOAuth2ClientWithHttpInfo(id, oauth2Client);
        return localVarResp.getData();
    }

    /**
     * Update an OAuth 2.0 Client Update an existing OAuth 2.0 Client. If you pass &#x60;client_secret&#x60; the secret
     * will be updated and returned via the API. This is the only time you will be able to retrieve the client secret,
     * so write it down and keep it safe.  OAuth 2.0 clients are used to perform OAuth 2.0 and OpenID Connect flows.
     * Usually, OAuth 2.0 clients are generated for applications which want to consume your OAuth 2.0 or OpenID Connect
     * capabilities.
     *
     * @param id           The id of the OAuth 2.0 Client. (required)
     * @param oauth2Client (required)
     * @return ApiResponse&lt;OAuth2Client&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> oAuth2Client </td><td>  -  </td></tr>
     * <tr><td> 0 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<OAuth2Client> updateOAuth2ClientWithHttpInfo(final String id, final OAuth2Client oauth2Client) throws ApiException {
        final okhttp3.Call localVarCall = this.updateOAuth2ClientValidateBeforeCall(id, oauth2Client, null);
        final Type localVarReturnType = new TypeToken<OAuth2Client>() {
        }.getType();
        return this.localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update an OAuth 2.0 Client (asynchronously) Update an existing OAuth 2.0 Client. If you pass
     * &#x60;client_secret&#x60; the secret will be updated and returned via the API. This is the only time you will be
     * able to retrieve the client secret, so write it down and keep it safe.  OAuth 2.0 clients are used to perform
     * OAuth 2.0 and OpenID Connect flows. Usually, OAuth 2.0 clients are generated for applications which want to
     * consume your OAuth 2.0 or OpenID Connect capabilities.
     *
     * @param id           The id of the OAuth 2.0 Client. (required)
     * @param oauth2Client (required)
     * @param _callback    The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details <table summary="Response Details" border="1">
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> oAuth2Client </td><td>  -  </td></tr>
     * <tr><td> 0 </td><td> jsonError </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateOAuth2ClientAsync(final String id, final OAuth2Client oauth2Client, final ApiCallback<OAuth2Client> _callback) throws ApiException {

        final okhttp3.Call localVarCall = this.updateOAuth2ClientValidateBeforeCall(id, oauth2Client, _callback);
        final Type localVarReturnType = new TypeToken<OAuth2Client>() {
        }.getType();
        this.localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
